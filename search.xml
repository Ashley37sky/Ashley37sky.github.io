<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cs229-numpy</title>
      <link href="/2024/01/25/%E8%AF%BE%E7%A8%8B/cs229/"/>
      <url>/2024/01/25/%E8%AF%BE%E7%A8%8B/cs229/</url>
      
        <content type="html"><![CDATA[<h1 id="cs229-numpy-matplotlib"><a href="#cs229-numpy-matplotlib" class="headerlink" title="cs229 numpy &amp; matplotlib"></a>cs229 numpy &amp; matplotlib</h1><span id="more"></span><ul><li><p>基本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建NumPy数组</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">zeros_arr = np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">ones_arr = np.ones((<span class="number">3</span>, <span class="number">3</span>)) </span><br><span class="line">identity_matrix = np.eye(<span class="number">4</span>)</span><br><span class="line">random_arr = np.random.rand(<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 创建一个3x3的随机数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">a.T <span class="comment"># 转置</span></span><br><span class="line">np.linalg.inv(a) </span><br><span class="line">mp.linalg.pinv(a) <span class="comment"># 伪逆矩阵</span></span><br><span class="line">self.theta = np.linalg.solve(X.T @ X, X.T @ y) <span class="comment"># 求解 ax=b</span></span><br><span class="line">I = np.eye(x_train.shape[<span class="number">1</span>]) <span class="comment"># identity</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组基本属性</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">shape = arr.shape  <span class="comment"># 获取数组形状 (2, 3)</span></span><br><span class="line">dimension = arr.ndim  <span class="comment"># 获取数组维度 2</span></span><br><span class="line">dtype = arr.dtype  <span class="comment"># 获取数组数据类型 int64</span></span><br><span class="line">size = arr.size  <span class="comment"># 获取数组元素总数</span></span><br><span class="line">mse = ((y_val_pred - y_val) ** <span class="number">2</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计</span></span><br><span class="line">sum_value = np.<span class="built_in">sum</span>(arr)</span><br><span class="line">mean_value = np.mean(arr)</span><br><span class="line">std_deviation = np.std(arr)</span><br><span class="line">numpy.linalg.norm(x, <span class="built_in">ord</span>=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>) <span class="comment"># 默认 l2_norm</span></span><br><span class="line">vector = np.array([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">l2_norm = np.linalg.norm(vector) <span class="comment">#5.0</span></span><br></pre></td></tr></table></figure></li><li><p>乘法</p><ul><li>*: 对应位置元素相乘</li><li>@: 向量点积 &#x2F; 矩阵乘法</li><li>np.dot(a,b):向量点积 &#x2F; 矩阵乘法</li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">vector2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">result = vector1 * vector2 <span class="comment"># [4 10 18]，对应位置元素相乘</span></span><br><span class="line">result = vector1 @ vector2 <span class="comment"># 点积的结果：32</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>data 相关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_train, y_train = util.load_dataset(train_path)</span><br><span class="line">y_predict = X @ self.theta</span><br></pre></td></tr></table></figure></li><li><p>matplotlib</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, num)</span><br><span class="line">    plt.plot(x_train[:, <span class="number">1</span>], y_train, <span class="string">&#x27;bx&#x27;</span>, label=<span class="string">&#x27;Training Set&#x27;</span>)</span><br><span class="line">    plt.plot(x_val[:, <span class="number">1</span>], y_val_pred, <span class="string">&#x27;ro&#x27;</span>, label=<span class="string">&#x27;Validation Set&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">f&quot;Tau = <span class="subst">&#123;tau&#125;</span>&quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> cs229 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs229 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs246-spark</title>
      <link href="/2024/01/25/%E8%AF%BE%E7%A8%8B/cs246/"/>
      <url>/2024/01/25/%E8%AF%BE%E7%A8%8B/cs246/</url>
      
        <content type="html"><![CDATA[<h1 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2>  <span id="more"></span><ul><li>SparkContext &amp; SparkSession<ul><li>SparkContext<ul><li>早期入口点，用于与Spark集群进行连接和通信</li><li>创建并操作RDD（Resilient Distributed Dataset）的主要入口点。RDD是Spark的基本数据抽象，用于分布式数据处理</li></ul></li><li>SparkSession：<ul><li>封装了SparkContext，并提供了对DataFrame和SQL操作的支持，同时还支持Spark Streaming、MLlib和GraphX等。</li></ul></li></ul></li></ul><h2 id="dataframe"><a href="#dataframe" class="headerlink" title="dataframe"></a>dataframe</h2><ul><li><p>创建SparkSession</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SparkSession</span></span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">    .appName(<span class="string">&quot;MySparkApp&quot;</span>) \  <span class="comment"># 设置应用程序名称</span></span><br><span class="line">    .config(<span class="string">&quot;spark.some.config.option&quot;</span>, <span class="string">&quot;config-value&quot;</span>) \  <span class="comment"># 配置Spark参数</span></span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure></li><li><p>读取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取 / 创建数据</span></span><br><span class="line"><span class="comment"># inferSchema=True, 自动推断列的数据类型, 否则全部视为字符串</span></span><br><span class="line">df = spark.read.csv(<span class="string">&quot;data.csv&quot;</span>, header=<span class="literal">True</span>, inferSchema=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = [(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>), (<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>)]</span><br><span class="line">df = spark.createDataFrame(data, [<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示数据</span></span><br><span class="line">df.show() <span class="comment"># top 20 in table</span></span><br><span class="line">df.printSchema() <span class="comment"># structure</span></span><br><span class="line">df.take(<span class="number">3</span>)</span><br><span class="line">df.count()</span><br></pre></td></tr></table></figure></li><li><p>持久化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.cache() <span class="comment"># 内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定level</span></span><br><span class="line">df.persist(storageLevel=StorageLevel.MEMORY_ONLY) <span class="comment"># MEMORY_ONLY、MEMORY_ONLY_SER、DISK_ONLY </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消：从内存中移除，释放内存资源</span></span><br><span class="line">df.unpersist()</span><br></pre></td></tr></table></figure></li><li><p>DataFrame操作: 聚合, 筛选, 排序, 连接等</p><ul><li><p>元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element = df.iloc[<span class="number">1</span>, <span class="number">2</span>] <span class="comment"># 二行三列</span></span><br><span class="line">element = df.at[<span class="number">3</span>, <span class="string">&quot;Name&quot;</span>] <span class="comment"># name列第四行</span></span><br></pre></td></tr></table></figure></li><li><p>列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.Age 等效 df[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">names_df = df.select(<span class="string">&quot;Name&quot;</span>) <span class="comment"># 选择列，创建一个新的DataFrame，name 不变</span></span><br><span class="line">renamed_df = df.select(df[<span class="string">&quot;Name&quot;</span>].alias(<span class="string">&quot;Full Name&quot;</span>)) <span class="comment"># 新的name</span></span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">&quot;NewColumn&quot;</span>, df[<span class="string">&quot;ExistingColumn&quot;</span>] * <span class="number">2</span>) <span class="comment"># 创建新的列，值是existing 的两倍</span></span><br><span class="line">df = df.withColumn(<span class="string">&quot;Age&quot;</span>, df[<span class="string">&quot;Age&quot;</span>] + <span class="number">1</span>) <span class="comment"># 更新列中的值（创建新的，覆盖）</span></span><br><span class="line"></span><br><span class="line">new_df = df.select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).withColumn(<span class="string">&quot;Category&quot;</span>, when(df.Age &gt; <span class="number">30</span>, <span class="string">&quot;Senior&quot;</span>).otherwise(<span class="string">&quot;Junior&quot;</span>)) <span class="comment"># ，new_df 是一个新的DataFrame，它包含了原始DataFrame中的 &quot;Name&quot; 和 &quot;Age&quot; 列，并添加了一个名为 &quot;Category&quot; 的新列，该列的值根据 &quot;Age&quot; 列的条件而确定</span></span><br><span class="line"></span><br><span class="line">df = df.drop(<span class="string">&quot;ColumnToRemove&quot;</span>) <span class="comment"># 删除列</span></span><br></pre></td></tr></table></figure></li><li><p>聚合: 平均值、总和、最大值、最小值、计数</p><ul><li><p>agg 基本用法：<code>df.agg(&#123;&quot;columnName&quot;: &quot;func 可自定义&quot;&#125;)</code></p><ul><li><code>avg</code>,<code>sum</code>,<code>min</code>,<code>count</code></li></ul></li><li><p>sum() avg() count()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">total_records = df.count() <span class="comment"># 行数</span></span><br><span class="line">total_sales = df.select(<span class="string">&quot;Sales&quot;</span>).<span class="built_in">sum</span>().collect()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">min_age = df.select(<span class="string">&quot;Age&quot;</span>).<span class="built_in">min</span>().collect()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df.agg(&#123;<span class="string">&quot;Salary&quot;</span>: <span class="string">&quot;avg&quot;</span>&#125;)</span><br><span class="line">df.agg(&#123;<span class="string">&quot;Salary&quot;</span>: <span class="string">&quot;avg&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="string">&quot;max&quot;</span>&#125;) <span class="comment"># 多个聚合操作，以一次性计算多个统计信息</span></span><br><span class="line"></span><br><span class="line">avg_salary = df.select(<span class="string">&quot;Salary&quot;</span>).agg(&#123;<span class="string">&quot;Salary&quot;</span>: <span class="string">&quot;avg&quot;</span>&#125;).first()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># average 只有一个元素，可以直接获取，first是第一行，[0]是第一个元素</span></span><br><span class="line"><span class="comment"># 但是一般是在分布式计算环境中进行计算，将最终结果提取到本地，以避免内存和性能问题</span></span><br><span class="line"></span><br><span class="line">avg_salary = df.select(<span class="string">&quot;Salary&quot;</span>).agg(&#123;<span class="string">&quot;Salary&quot;</span>: <span class="string">&quot;avg&quot;</span>&#125;).collect()[<span class="number">0</span>][<span class="number">0</span>] </span><br><span class="line"><span class="comment"># 1. agg 返回dataframe （在分布式节点上运算，数据分布在很多节点上，所以要获取数据，先collect到本地的数据结构中）</span></span><br><span class="line"><span class="comment"># 2. collect() 返回一个列表，列表的元素是row对象 （直接理解成table就行了）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>groupBy: 汇总，一半跟在聚合后</p><ul><li>groupBy 按照指定的列进行分组，创建一个分组对象。可以在对分组对象使用agg计算统计值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grouped_df = df.groupBy(<span class="string">&quot;Category&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合操作</span></span><br><span class="line">result_df = df.groupBy(<span class="string">&quot;Category&quot;</span>).agg(&#123;<span class="string">&quot;Value&quot;</span>: <span class="string">&quot;sum&quot;</span>, <span class="string">&quot;Quantity&quot;</span>: <span class="string">&quot;avg&quot;</span>&#125;) <span class="comment"># result dataframe 有三列： Category ｜ Value ｜ Quantity</span></span><br><span class="line">sum_df = df.groupBy(<span class="string">&quot;Category&quot;</span>).<span class="built_in">sum</span>(<span class="string">&quot;Value&quot;</span>)</span><br><span class="line">avg_df = df.groupBy(<span class="string">&quot;Category&quot;</span>).avg(<span class="string">&quot;Quantity&quot;</span>)</span><br><span class="line">baskets = transaction.groupBy(<span class="string">&#x27;order_id&#x27;</span>).agg(collect_set(<span class="string">&#x27;product_name&#x27;</span>).alias(<span class="string">&#x27;products&#x27;</span>)) <span class="comment"># 变成set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计操作</span></span><br><span class="line">count_df = df.groupBy(<span class="string">&quot;Category&quot;</span>).count() <span class="comment"># dataframe: Category | count</span></span><br><span class="line">result = df.groupBy(<span class="string">&quot;ColumnToGroupBy&quot;</span>).agg(count(<span class="string">&quot;*&quot;</span>).alias(<span class="string">&quot;RecordCount&quot;</span>)) <span class="comment"># * 计算所有非空记录的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">filtered_df = df.groupBy(<span class="string">&quot;Category&quot;</span>).<span class="built_in">filter</span>(df[<span class="string">&quot;Value&quot;</span>] &gt; <span class="number">100</span>) <span class="comment"># dataframe: Category | </span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>筛选 </p><ul><li>filter &#x2F; where</li><li>返回一个新的DataFrame</li><li>逻辑运算符（ &amp;  |）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filtered_df = df.<span class="built_in">filter</span>(df.Age &gt; <span class="number">30</span>)</span><br><span class="line">filtered_df = df.<span class="built_in">filter</span>(df[<span class="string">&quot;ColumnName&quot;</span>] &gt; <span class="number">30</span>)</span><br><span class="line">filtered_df = df.select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).<span class="built_in">filter</span>(df.Age &gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">filtered_df = df.where(df[<span class="string">&quot;ColumnName&quot;</span>] &gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">filtered_df = df.<span class="built_in">filter</span>((df[<span class="string">&quot;Age&quot;</span>] &gt; <span class="number">30</span>) &amp; (df[<span class="string">&quot;Gender&quot;</span>] == <span class="string">&quot;Male&quot;</span>)) <span class="comment"># 筛选出年龄大于30且性别为&quot;男&quot;的行</span></span><br><span class="line"></span><br><span class="line">jun_29_operations = Bombing_Operations.where(<span class="string">&quot;MissionDate = &#x27;1966-06-29&#x27; AND TargetCountry=&#x27;NORTH VIETNAM&#x27;&quot;</span>) <span class="comment"># sql </span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>排序 </p><ul><li>生成新的DataFrame，包含所有列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># orderBy</span></span><br><span class="line">sorted_df = df.orderBy(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">sorted_df = df.orderBy(df[<span class="string">&quot;Column1&quot;</span>].asc(), df[<span class="string">&quot;Column2&quot;</span>].desc())   <span class="comment"># 按照多个列进行排序，先按照列1升序，然后按照列2降序</span></span><br><span class="line">sorted_df = df.orderBy(<span class="string">&quot;ColumnName&quot;</span>).select(<span class="string">&quot;ColumnName&quot;</span>)  <span class="comment"># 仅仅包含排序的列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sort</span></span><br><span class="line">sorted_df = df.sort.(desc(<span class="string">&quot;freq&quot;</span>))</span><br><span class="line">df1 = df.groupBy(<span class="string">&quot;col1&quot;</span>).agg(count(<span class="string">&quot;*&quot;</span>).alias(<span class="string">&quot;col2&quot;</span>)).sort(desc(<span class="string">&quot;MissionsCount&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接</p><ul><li>inner: 返回都存在匹配的行</li><li>outer：返回所有的，不匹配填充null</li><li>left：以左侧为基准，返回右边匹配的，右边没有的返回null</li><li>right</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format</span></span><br><span class="line">joined_df = df1.join(df2, on=<span class="string">&quot;common_column&quot;</span>, how=<span class="string">&quot;xxxtype&quot;</span>) </span><br><span class="line">missions_joined = df1.join(df2, df1.col == df2.col)</span><br><span class="line"></span><br><span class="line">merged_df = df.select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).join(address_df, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment"># df 中的 name age 形成新的dataframe</span></span><br><span class="line"><span class="comment"># 新的frame 和 名为 address_df 的DataFrame进行连接。连接的条件是 &quot;Name&quot; 列，即两个DataFrame中的 &quot;Name&quot; 列必须具有相同的值才会进行连接</span></span><br><span class="line"></span><br><span class="line">missions_joined = df1.join(df2, df1.col == df2.col)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SQL查询</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line">result = spark.sql(<span class="string">&quot;SELECT * FROM people WHERE Age &gt; 30&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>保存数据</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.write.csv(<span class="string">&quot;output.csv&quot;</span>)</span><br><span class="line">df.write.mode(<span class="string">&#x27;overwrite&#x27;</span>).json(<span class="string">&quot;df.json&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>停止SparkSession</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.stop()</span><br></pre></td></tr></table></figure></li></ul><h2 id="pandas-matplotlib"><a href="#pandas-matplotlib" class="headerlink" title="pandas % matplotlib"></a>pandas % matplotlib</h2><ul><li>when the size of df is small, we can move to pandas and conduct visualization<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pd = df.toPandas()</span><br><span class="line">pd.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># bar chart</span></span><br><span class="line">pl = missions_count_pd.plot(kind=<span class="string">&quot;bar&quot;</span>,</span><br><span class="line">                            x=<span class="string">&quot;Contr&quot;</span>, y=<span class="string">&quot;MissionsCount&quot;</span>,</span><br><span class="line">                            figsize=(<span class="number">10</span>, <span class="number">7</span>), log=<span class="literal">True</span>, alpha=<span class="number">0.5</span>, color=<span class="string">&quot;olive&quot;</span>) <span class="comment"># alpha 透明度的参数</span></span><br><span class="line">pl.set_xlabel(<span class="string">&quot;Country&quot;</span>)</span><br><span class="line">pl.set_ylabel(<span class="string">&quot;Number of Missions (Log scale)&quot;</span>)</span><br><span class="line">pl.set_title(<span class="string">&quot;Number of missions by Country&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对聚合后的每一个组画图</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># iterate the different groups to create a different series</span></span><br><span class="line"><span class="keyword">for</span> country, missions <span class="keyword">in</span> missions_by_date.groupby(<span class="string">&quot;ContryFlyingMission&quot;</span>):</span><br><span class="line">    plt.plot(missions[<span class="string">&quot;MissionDate&quot;</span>], missions[<span class="string">&quot;MissionsCount&quot;</span>], label=country)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="rdd"><a href="#rdd" class="headerlink" title="rdd"></a>rdd</h2><ul><li><p>创建rdd</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line">sc = SparkContext(<span class="string">&quot;local&quot;</span>, <span class="string">&quot;MyRDDApp&quot;</span>)  <span class="comment"># 创建SparkContext</span></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">rdd = sc.parallelize(data)  <span class="comment"># 从现有数据创建RDD. 将传递给它的数据集合分布到 Spark 集群中的多个节点上</span></span><br><span class="line"></span><br><span class="line">rdd.take(<span class="number">3</span>) <span class="comment"># 显现</span></span><br></pre></td></tr></table></figure></li><li><p>转换操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map将每个元素加倍</span></span><br><span class="line">rdd_doubled = rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用filter筛选出偶数</span></span><br><span class="line">rdd_even = rdd.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用reduce将所有元素相加</span></span><br><span class="line">total_sum = rdd.reduce(<span class="keyword">lambda</span> x, y: x + y)</span><br></pre></td></tr></table></figure></li><li><p>持久化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rdd.persist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将RDD持久化到内存</span></span><br><span class="line">rdd.persist(StorageLevel.MEMORY_ONLY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将RDD持久化到磁盘</span></span><br><span class="line">rdd.persist(StorageLevel.DISK_ONLY)</span><br></pre></td></tr></table></figure><ul><li>Example: 需要反复操作大型数据时使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建大型RDD</span></span><br><span class="line">large_rdd = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将RDD持久化到磁盘</span></span><br><span class="line">large_rdd.persist(StorageLevel.DISK_ONLY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行多个操作，多次重复使用数据</span></span><br><span class="line">sum_result = large_rdd.reduce(<span class="keyword">lambda</span> x, y: x + y)</span><br><span class="line">avg_result = large_rdd.mean()</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>行动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取RDD中的所有元素并返回为列表</span></span><br><span class="line">elements = rdd.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算RDD中的元素数量</span></span><br><span class="line">count = rdd.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个元素</span></span><br><span class="line">first_element = rdd.first()</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.stop()</span><br></pre></td></tr></table></figure></li></ul><h2 id="colab0-Map-Reduce"><a href="#colab0-Map-Reduce" class="headerlink" title="colab0 - Map Reduce"></a>colab0 - Map Reduce</h2><ol><li>implicit - dataframe<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TakeoffLocationCounts = jun_29_operations\</span><br><span class="line">                         .groupBy(<span class="string">&quot;TakeoffLocation&quot;</span>).agg(count(<span class="string">&quot;*&quot;</span>).alias(<span class="string">&quot;MissionsCount&quot;</span>))\</span><br><span class="line">                         .sort(desc(<span class="string">&quot;MissionsCount&quot;</span>))</span><br></pre></td></tr></table></figure></li><li>explicit - rdd <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># emit a pair</span></span><br><span class="line">all_locations = jun_29_operations.rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> row: (row.TakeoffLocation, <span class="number">1</span>)) <span class="comment"># [(&#x27;TAKHLI&#x27;, 1), (&#x27;DANANG&#x27;, 1), (&#x27;CONSTELLATION&#x27;, 1)] 先从df-&gt;rdd, 然后把每行变成一个tuple (location, 1)</span></span><br><span class="line">locations_counts_rdd = all_locations.reduceByKey(<span class="keyword">lambda</span> a, b: a+b).sortBy(<span class="keyword">lambda</span> r: -r[<span class="number">1</span>]) <span class="comment"># [(&#x27;CONSTELLATION&#x27;, 87), (&#x27;TAKHLI&#x27;, 56), (&#x27;KORAT&#x27;, 55)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rdd-&gt;df</span></span><br><span class="line">locations_counts_with_schema = locations_counts_rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> r: Row(TakeoffLocation=r[<span class="number">0</span>], MissionsCount=r[<span class="number">1</span>]))</span><br><span class="line">locations_counts = spark.createDataFrame(locations_counts_with_schema)</span><br></pre></td></tr></table></figure></li></ol><h2 id="colab1-word-count"><a href="#colab1-word-count" class="headerlink" title="colab1 - word count"></a>colab1 - word count</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">txt = spark.read.text(<span class="string">&quot;pg100.txt&quot;</span>) <span class="comment"># 一列n行，每一行是一行文本</span></span><br><span class="line">split_cols = split(lower(col(<span class="string">&#x27;value&#x27;</span>)), <span class="string">&quot; &quot;</span>) <span class="comment"># 返回 df 中的 列对象</span></span><br><span class="line">words = txt.select(explode(split_cols).alias(<span class="string">&quot;word&quot;</span>)) <span class="comment"># explode() 函数将数组中的每个元素拆分成多行; words df 中有一列 word</span></span><br><span class="line"></span><br><span class="line">filtered_words = words.where(<span class="string">&quot;word != &#x27;&#x27; and word rlike &#x27;^[a-z]&#x27;&quot;</span>)</span><br><span class="line">first_letter = filtered_words.select(col(<span class="string">&quot;word&quot;</span>).substr(<span class="number">1</span>, <span class="number">1</span>).alias(<span class="string">&quot;first_letter&quot;</span>))</span><br><span class="line">letter_counts = first_letter.groupBy(<span class="string">&quot;first_letter&quot;</span>)\</span><br><span class="line">                .agg(count(<span class="string">&quot;*&quot;</span>).alias(<span class="string">&quot;Count&quot;</span>))\</span><br><span class="line">                .sort(asc(<span class="string">&quot;first_letter&quot;</span>))</span><br><span class="line"></span><br><span class="line">letter_counts.show(<span class="number">26</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cs246 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs246 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Re-Set-Up</title>
      <link href="/2023/10/14/%E5%85%B6%E4%BB%96/blog-reset-up/"/>
      <url>/2023/10/14/%E5%85%B6%E4%BB%96/blog-reset-up/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol><li><code>git clone [hexo brach]</code><span id="more"></span></li><li>download npm</li><li><code>npm install hexo</code></li><li><code>npm install hexo-deployer-git</code></li></ol><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul><li><code>hexo h</code></li><li><code>hexo new &lt;title&gt;</code></li><li><code>hexo g</code></li><li><code>hexo s</code></li><li><code>hexo clean</code></li><li><code>hexo deploy</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 基础入门</title>
      <link href="/2022/07/17/C++/1_cpp_basic/"/>
      <url>/2022/07/17/C++/1_cpp_basic/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++ 基础入门"></a><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC1%E9%98%B6%E6%AE%B5C%2B%2B%20%E5%8C%A0%E5%BF%83%E4%B9%8B%E4%BD%9C%20%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%AE%B2%E4%B9%89/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">C++ 基础入门</a></h1><h2 id="1-初识"><a href="#1-初识" class="headerlink" title="1. 初识"></a>1. 初识</h2><ul><li><p>注释</p><ul><li><p>单行注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述信息</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 描述信息 */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><span id="more"></span><ul><li><p>常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> day 7 <span class="comment">//宏常量</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>; <span class="comment">//const修饰变量</span></span><br></pre></td></tr></table></figure></li><li><p>命名规则</p><ul><li>字母或下划线 开头</li><li>区分大小写</li></ul></li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><ul><li><p>统计数据类型所占内存大小 <code>sizeof()</code></p></li><li><p>整形</p><ul><li><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table></li></ul></li><li><p>浮点型</p><ul><li><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f1 = <span class="number">3.14f</span>; <span class="comment">// 末尾f</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure></li><li></li><li><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table></li></ul></li><li><p>字符</p><ul><li><code>char ch = &#39;a&#39;</code><ul><li>单引号</li><li>1 byte</li></ul></li><li>转义 <code>\n \t \\</code></li></ul></li><li><p>字符串</p><ul><li><p>C style </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>C++ style</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><ul><li>逻辑<ul><li>&amp;&amp;: and</li><li>||: or</li></ul></li></ul><h2 id="4-运行结构"><a href="#4-运行结构" class="headerlink" title="4 运行结构"></a>4 运行结构</h2><ul><li><p>选择</p><ul><li><pre><code class="cpp">if ()    ...;else if()    ...;else    ...;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ```cpp</span><br><span class="line">  c = a &gt; b ? a : b; // 三目运算</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="cpp">switch(a) // int 或者 char&#123;    case 1：        执行语句;        break;    case 2：        执行语句;        break;    default:        执行语句;        break;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 5 数组</span><br><span class="line"></span><br><span class="line">+ 连续的内存</span><br><span class="line"></span><br><span class="line">+ 一维数组</span><br><span class="line"></span><br><span class="line">  + 定义</span><br><span class="line"></span><br><span class="line">    ```cpp</span><br><span class="line">    int score[10];</span><br><span class="line">    int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;;</span><br><span class="line">    int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>数组名</p><ul><li>数组名是常量 – 地址</li><li>元素地址 &amp;arr[0]</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二维数组</p><ul><li><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>数组名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 元素&amp;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><ul><li><p>函数是value传递，不影响实参</p></li><li><p>声明 &amp; 定义</p><ul><li><p>声明 （many times）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>定义 （once）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>大型项目 - 分文件编写</p><ul><li><p>创建后缀名为.h的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 声明</span></span><br></pre></td></tr></table></figure></li><li><p>创建后缀名为function.cpp的源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span> <span class="comment">// 双引号-自定义文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span> <span class="comment">// 自定义 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="** 7 指针"></a>** 7 指针</h2><ul><li><p>概念</p><ul><li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p></li><li><p>指针变量 –&gt; 保存地址 –&gt; 间接访问内存 (解引用 <code>*</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> * p = &amp;a;</span><br><span class="line"><span class="comment">// *p = a</span></span><br><span class="line"><span class="comment">// p = &amp;a</span></span><br></pre></td></tr></table></figure></li><li><p>所占内存空间  –&gt; 传递给函数的时候，节省空间（不用复制）&#x2F; 修改实参</p><ul><li>32位系统：4 byte</li><li>64位系统：8 byte</li></ul></li></ul></li><li><p>空指针和野指针：指向非申请的空间，不能访问</p><ul><li>空指针：指向内存中编号为0的空间<ul><li>用途：初始化指针变量</li><li>注意：空指针指向的内存是不可以访问</li></ul></li><li>野指针：指向非法的内存空间  <code>int * p = (int *)0x1100</code></li></ul></li><li><p><code>const</code> 修饰</p><ul><li>常量指针 <code>const int * p1 </code> –&gt; 不能修改值（*p）</li><li>指针常量 <code>int * const p1</code> –&gt; 不能修改指向的地址 (p)</li><li>修饰指针 + 常量 <code>const int * const p</code></li></ul></li><li><p>指针和数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * p = arr[0]</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//利用指针遍历数组</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++; <span class="comment">// 增加4byte到下一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针和函数：指针作为函数参数，会修改实参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="**8 结构体"></a>**8 结构体</h2><ul><li><p>what: 自定义数据类型</p></li><li><p>定义和使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student stu1; <span class="comment">// 或者 struct Student stu1;</span></span><br><span class="line">student stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>结构体数组：数组的成员是结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结构体指针：通过指针访问结构体中的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">cout &lt;&lt; p-&gt;name &lt;&lt;endl; </span><br><span class="line">cout &lt;&lt; (*p).name &lt;&lt;endl;</span><br></pre></td></tr></table></figure></li><li><p>结构体的嵌套</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;  <span class="comment">//教师姓名</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结构体做函数参数</p><ul><li>值传递 <code>void printStudent(student stu );</code></li><li>地址传递 <code>void printStudent2(student *stu);</code></li></ul></li><li><p><code>const</code> 防止误写操作</p><ul><li><p>why: 一般使用函数的时候传入结构体指针，而不是复制本来节省空间；所以为了防止在函数中对于实际参数的值的改变，可以用<code>const</code>加以限制 (不能修改value)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">100</span>; <span class="comment">//操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C5-Backtrack</title>
      <link href="/2022/02/23/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C6-Backtrack/"/>
      <url>/2022/02/23/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C6-Backtrack/</url>
      
        <content type="html"><![CDATA[<h1 id="Backtrack-回溯法"><a href="#Backtrack-回溯法" class="headerlink" title="Backtrack 回溯法"></a>Backtrack 回溯法</h1><ul><li><p>介绍</p><ul><li><p>回溯法本质就是利用递归进行暴力搜索，解决 for 循环不好解决的问题 </p></li><li><p>回溯法可以抽象 Tree</p><span id="more"></span><ul><li><p>for -  平层遍历</p></li><li><p>递归 - 向下（深度）走</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                  root</span><br><span class="line">       1        2          3        4</span><br><span class="line">     (234)     (34)       (4)       ()</span><br><span class="line">   2  3   4     3  4        4            </span><br><span class="line">(34) (4)   ....</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, path</span>):</span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        ans.append(path[:]) <span class="comment"># 要复制 element，不然指向同一个地方</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">        path.append(num[i])</span><br><span class="line">        backtrack(i+<span class="number">1</span>, path)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure></li><li><p>进阶：减枝操作</p></li></ul></li><li><p>补充：</p><ul><li><p><strong>在python中是没有自增和自减的，但在python中存在 i &#x3D; i + 1和 i &#x3D; i -1 的情况。</strong></p><p><strong>因为Python的模型规定，数值对象是不可改变的。 i &#x3D; i + 1 相当于重新创建了一个变量 i ，而不是改变了 i 中的数值。</strong></p><p><strong>++i &#x3D; +(+i)</strong>   –&gt; ++2 equals 2</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans = [<span class="number">1</span>]</span><br><span class="line">temp = [<span class="number">2</span>]</span><br><span class="line">ans.append(temp) <span class="comment"># [1, [2]]</span></span><br><span class="line">ans += temp <span class="comment"># [1, 2]  必须是两个list的连接</span></span><br></pre></td></tr></table></figure><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul><li>77 Combinations</li><li>78 Subsets</li><li>46 Permutations</li></ul><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>Backtrack的核心是三道题. 这三道题覆盖了很多其他题目.</p><ul><li>40 Combination Sum II  (组合)</li><li>47 Permutations II  (排列)</li><li>90 Subsets II  (组合).</li></ul><h3 id="好题"><a href="#好题" class="headerlink" title="好题"></a>好题</h3><p>好题是难度跟核心类似但普遍性稍差的题目. </p><ul><li>131 Palindrome Partition 这道本质不难. 就是复合题.  i+1组合复杂条件判断组合双指针. </li><li>698 Partition to K Equal Sum Subsets. 跟上面的131一样, 也是i+1条件判断跳跃. 只不过这道更难更复杂. 目前在条件判断跳跃之中, 这道是最难的.   可以理解为更加复杂的40题. 40题如果刷熟了的话可以刷这道.</li></ul><h3 id="题号"><a href="#题号" class="headerlink" title="题号"></a>题号</h3><ul><li>78 Subsets (combination)</li><li>90 Subsets II(必刷)</li><li>46 Permutations</li><li>47 Permutations II (必刷)</li><li>77 Combinations</li><li>39 Combination Sum (简单)</li><li>40 Combination Sum II (必刷)</li><li>216 Combination Sum III</li><li>377 Combination Sum IV (没做)</li><li>131 Palindrome Partition</li><li>132 Palindrome Partitioning II (DP)</li><li>1278 Palindrome Partitioning III (DP)</li><li>1745 Palindrome Partitioning IV (DP)</li><li>267 Palindrome Permutation II (和47题重复)</li><li>17 Letter Combinations of a Phone Number</li><li>698 Partition to K Equal Sum Subsets</li></ul><p>偏题&#x2F;难题: </p><ul><li>60  Permutation Sequence</li><li>1048 Longest String Chain</li></ul><p>应用题: </p><ul><li>1152</li><li>526 Beautiful Arrangement</li><li>126</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="类型一：组合"><a href="#类型一：组合" class="headerlink" title="类型一：组合"></a>类型一：组合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, path</span>): <span class="comment"># 模板</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        ans.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n): <span class="comment"># 不往回走</span></span><br><span class="line">        path.append(num[i])</span><br><span class="line">        <span class="keyword">if</span> i != start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 查重</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        backtrack(i+<span class="number">1</span>, path)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure><h4 id="LC78-Subsets"><a href="#LC78-Subsets" class="headerlink" title="LC78 - Subsets"></a>LC78 - Subsets</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: <span class="comment"># 推荐写法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start, curr</span>):</span><br><span class="line">            <span class="comment"># 这里重要, 必须curr[:]的意义跟 java讲过的是一样的, 必须新建一个list</span></span><br><span class="line">            output.append(curr[:])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                curr.append(nums[i])</span><br><span class="line">                dfs(i + <span class="number">1</span>, curr)</span><br><span class="line">                curr.pop()</span><br><span class="line">        </span><br><span class="line">        output = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dfs(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><ul><li><p>其他解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 解法1 - 递推</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line"></span><br><span class="line">        ans= [[]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ans += [ cur + [num] <span class="keyword">for</span> cur <span class="keyword">in</span> ans ] <span class="comment"># num:int [num]:list</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 解法2 - 二进制映射</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">    </span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**n, <span class="number">2</span>**(n + <span class="number">1</span>)):</span><br><span class="line">            bitmask = <span class="built_in">bin</span>(i)[<span class="number">3</span>:] <span class="comment"># 0bxxxx</span></span><br><span class="line">            ans.append([nums[j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> bitmask[j] == <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># backtrack 按照长度输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">    </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans= []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start = <span class="number">0</span>, cur = []</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == k:</span><br><span class="line">                ans.append(cur[:]) </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                backtrack(i + <span class="number">1</span>, cur) <span class="comment"># 往前搜索</span></span><br><span class="line">                cur.pop() <span class="comment"># 回退</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>): <span class="comment"># length from 0 to n</span></span><br><span class="line">            backtrack()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul><h4 id="LC90-Subsets-II"><a href="#LC90-Subsets-II" class="headerlink" title="LC90 - Subsets II"></a>LC90 - Subsets II</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2]</span><br><span class="line">Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]  # 不会有两个[2]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start = <span class="number">0</span>, cur = [], summ = <span class="number">0</span></span>):</span><br><span class="line"></span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="keyword">if</span> i != start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># NO REPEAT</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, summ + nums[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="LC77-Combinations"><a href="#LC77-Combinations" class="headerlink" title="LC77_Combinations"></a>LC77_Combinations</h4><ul><li><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start = <span class="number">0</span>, cur = [], l = <span class="number">0</span></span>):</span><br><span class="line">            <span class="keyword">if</span> l == k:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                cur.append(i + <span class="number">1</span>)</span><br><span class="line">                dfs(i + <span class="number">1</span>, cur, l + <span class="number">1</span>)</span><br><span class="line">                cur.pop()</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="LC39-Combination-Sum"><a href="#LC39-Combination-Sum" class="headerlink" title="LC39 - Combination Sum"></a>LC39 - Combination Sum</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start = <span class="number">0</span>, cur = [], summ = <span class="number">0</span></span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> summ &gt;= target:</span><br><span class="line">                <span class="keyword">if</span> summ == target:</span><br><span class="line">                    ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                cur.append(candidates[i])</span><br><span class="line">                dfs(i, cur, summ + candidates[i])  <span class="comment"># 避免了在cur.append后和pop和修改sum</span></span><br><span class="line">                cur.pop()</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="LC40-Combination-Sum-II-（查重）"><a href="#LC40-Combination-Sum-II-（查重）" class="headerlink" title="LC40 - Combination Sum II （查重）"></a>LC40 - Combination Sum II （查重）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span> <span class="comment"># [1,2,2,2,5]</span></span><br><span class="line">Output:  <span class="comment"># 不允许重复数组</span></span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], <span class="comment"># 有3个2，但是[1,2,2]只能出现一此</span></span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>Key: continue, return<ul><li>一开始要去重, 通过去重避免重走相同元素. 去重分两步, 一开始要sort, 之后backtrack的时候要查跟前一个元素是否一</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start = <span class="number">0</span>, cur = [], summ = <span class="number">0</span></span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> summ == target:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="keyword">if</span> i != start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]: <span class="comment"># 平层无重复，类似信息论 无前缀编码</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> summ + candidates[i] &gt; target: <span class="comment"># 剪枝：不用向下搜索，加快速度</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                cur.append(candidates[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, summ + candidates[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">        </span><br><span class="line">        candidates.sort() <span class="comment"># 方便去重</span></span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="类型二：排列"><a href="#类型二：排列" class="headerlink" title="类型二：排列"></a>类型二：排列</h2><ul><li>key：<ul><li>不从 start 开始走，从头开始走。但是需要记录某一个元素时候走过 <code>flag</code></li><li>查重 –&gt; 记录count （思想：<code>无前缀编码</code>）</li></ul></li></ul><h4 id="LC46-Permutations"><a href="#LC46-Permutations" class="headerlink" title="LC46_Permutations"></a>LC46_Permutations</h4><ul><li><pre><code>Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution(object):</span><br><span class="line">    def permute(self, nums):</span><br><span class="line">        </span><br><span class="line">        def dfs(cur = [], flag = [], l = 0):</span><br><span class="line">            if l == n:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            for i in range(n): # 不从start开始，can go back</span><br><span class="line">                if nums[i] not in flag: # no repeat element</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    flag.append(nums[i])</span><br><span class="line">                    dfs(cur, flag, l+1)</span><br><span class="line">                    cur.pop()</span><br><span class="line">                    flag.pop()</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs()</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure></code></pre></li></ul><h4 id="LC47-Permutations-II-（查重）"><a href="#LC47-Permutations-II-（查重）" class="headerlink" title="LC47 - Permutations II （查重）"></a>LC47 - Permutations II （查重）</h4><ul><li><p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="comment"># 不允许重复 不会出现两个 [1,1,2]</span></span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></li><li><p>key: 避免重复，用Hashmap存数量 （重复类比<code>无前缀编码</code>）</p><p><a href="https://www.youtube.com/watch?v=qhBVWf0YafA&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo&index=4">讲解</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur = []</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == n:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> count: <span class="comment"># 不从start开始，can go back</span></span><br><span class="line">                <span class="keyword">if</span> count[key] &gt; <span class="number">0</span>:</span><br><span class="line">                    cur.append(key)</span><br><span class="line">                    count[key] -= <span class="number">1</span></span><br><span class="line">                    dfs(cur)</span><br><span class="line">                    cur.pop()</span><br><span class="line">                    count[key] += <span class="number">1</span></span><br><span class="line">                 </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            count[nums[i]] = count.get(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">               </span><br><span class="line">        dfs()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C5-Matrix Traversal</title>
      <link href="/2022/02/18/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C5-MatrixTraversal/"/>
      <url>/2022/02/18/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C5-MatrixTraversal/</url>
      
        <content type="html"><![CDATA[<h1 id="Matrix-Traversal"><a href="#Matrix-Traversal" class="headerlink" title="Matrix Traversal"></a>Matrix Traversal</h1><p>题目见<code>练习</code></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>DFS 模板</li><li>染色, 去色（需要回溯）</li></ul><span id="more"></span><h2 id="Problems-（没做）"><a href="#Problems-（没做）" class="headerlink" title="Problems （没做）"></a>Problems （没做）</h2><ul><li>Leetcode练习: 1730, 岛系题目, 490</li><li>剑指: 12(涉及回溯), 47涉及动态规划. 基本都涉及其他知识.</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Chess</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="LC-200-Number-of-Islands-（DFS）"><a href="#LC-200-Number-of-Islands-（DFS）" class="headerlink" title="LC 200 - Number of Islands （DFS）"></a>LC 200 - Number of Islands （DFS）</h2><ul><li><p><a href="https://leetcode.com/problems/number-of-islands/discuss/1731734/Iterative-Solution-(using-DFS-Java)">No Iteration</a> and <a href="https://leetcode.com/problems/number-of-islands/discuss/1758785/Python-DFS-solution">python Iteration </a> (不推荐，复杂难写)</p></li><li><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p></li><li><p>key: 代码易读性</p><ul><li>Check Boundary</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">checkBoundary</span>(<span class="params">row, col</span>):</span><br><span class="line">            <span class="keyword">return</span> row&gt;=<span class="number">0</span> <span class="keyword">and</span> col&gt;=<span class="number">0</span> <span class="keyword">and</span> row&lt;ROW <span class="keyword">and</span> col&lt;COL <span class="keyword">and</span> grid[row][col] == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">row, col</span>):</span><br><span class="line">            <span class="keyword">if</span> checkBoundary(row, col):</span><br><span class="line">                grid[row][col] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">                dfs(row + <span class="number">1</span>, col)</span><br><span class="line">                dfs(row - <span class="number">1</span>, col)</span><br><span class="line">                dfs(row, col + <span class="number">1</span>)</span><br><span class="line">                dfs(row, col - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">              </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        ROW, COL = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(ROW):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(COL):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dfs(row, col)</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="LC-79-Word-Search-（Backtrack）"><a href="#LC-79-Word-Search-（Backtrack）" class="headerlink" title="LC 79 - Word Search （Backtrack）"></a>LC 79 - Word Search （Backtrack）</h2><ul><li>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</li><li>key: backtrack, 记得还原</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board, word</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        ROW, COL = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">checkBoundary</span>(<span class="params">row, col ,index</span>):</span><br><span class="line">            <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; ROW <span class="keyword">and</span> col &lt; COL <span class="keyword">and</span> board[row][col] == word[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">row, col, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> checkBoundary(row, col ,index):</span><br><span class="line">                char = board[row][col]</span><br><span class="line">                board[row][col] = <span class="string">&quot;#&quot;</span></span><br><span class="line">                path = search(row+<span class="number">1</span>, col, index + <span class="number">1</span>) <span class="keyword">or</span> search(row, col+<span class="number">1</span>, index + <span class="number">1</span>) <span class="keyword">or</span> search(row-<span class="number">1</span>, col, index + <span class="number">1</span>) <span class="keyword">or</span> search(row, col-<span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">                board[row][col] = char  <span class="comment"># 记得还原 </span></span><br><span class="line">                <span class="keyword">return</span> path</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(ROW):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(COL):</span><br><span class="line">                <span class="keyword">if</span> search(row, col, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="LC-994-Rotting-Oranges-BFS"><a href="#LC-994-Rotting-Oranges-BFS" class="headerlink" title="LC 994 - Rotting Oranges (BFS)"></a>LC 994 - Rotting Oranges (BFS)</h2><ul><li>多少天橘子全部烂完（烂橘子感染四周的好橘子）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">orangesRotting</span>(<span class="params">self, grid</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">       :rtype: int</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       visit, curr = <span class="built_in">set</span>(), deque()</span><br><span class="line">       days = <span class="number">0</span></span><br><span class="line">       </span><br><span class="line"><span class="comment"># find all fresh and rotten oranges</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">               <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>: <span class="comment"># 避免最后还需要遍历一次看有无新鲜</span></span><br><span class="line">                   visit.add((i, j))</span><br><span class="line">               <span class="keyword">elif</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                   curr.append((i, j))</span><br><span class="line">                   </span><br><span class="line">       <span class="keyword">while</span> visit <span class="keyword">and</span> curr:</span><br><span class="line">           <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(curr)):</span><br><span class="line">               i, j = curr.popleft()  <span class="comment"># obtain recent rotten orange</span></span><br><span class="line">               <span class="keyword">for</span> coord <span class="keyword">in</span> ((i-<span class="number">1</span>, j), (i+<span class="number">1</span>, j), (i, j-<span class="number">1</span>), (i, j+<span class="number">1</span>)):</span><br><span class="line">                   <span class="keyword">if</span> coord <span class="keyword">in</span> visit:  <span class="comment"># check if adjacent orange is fresh</span></span><br><span class="line">                       visit.remove(coord)</span><br><span class="line">                       curr.append(coord)</span><br><span class="line">           days += <span class="number">1</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> visit: <span class="comment"># check if fresh oranges remain</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">       <span class="keyword">return</span> days</span><br></pre></td></tr></table></figure><h2 id="LC-827-Making-A-Large-Island"><a href="#LC-827-Making-A-Large-Island" class="headerlink" title="LC 827 - Making A Large Island"></a>LC 827 - Making A Large Island</h2><ul><li>You are given an <code>n x n</code> binary matrix <code>grid</code>. You are allowed to change <strong>at most one</strong> <code>0</code> to be <code>1</code>.</li><li>key:<ul><li>怎么区分连接的是一个岛（ans &#x3D; island[i] + 1）还是两个岛屿 (ans &#x3D; island[i] + [j]) –&gt; 不同岛染不同颜色</li><li>怎么maximum –&gt; 遍历所有零界点，求maximum</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestIsland</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">CheckBoundary</span>(<span class="params">row, col</span>):</span><br><span class="line">            <span class="keyword">return</span> row&gt;=<span class="number">0</span> <span class="keyword">and</span> col&gt;=<span class="number">0</span> <span class="keyword">and</span> row&lt;n <span class="keyword">and</span> col&lt;n</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">row, col, index</span>):</span><br><span class="line">            areas = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> CheckBoundary(row, col) <span class="keyword">and</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                grid[row][col] = index</span><br><span class="line">                areas += <span class="number">1</span></span><br><span class="line">                areas += dfs(row+<span class="number">1</span>, col, index) + dfs(row-<span class="number">1</span>, col, index) + dfs(row, col+<span class="number">1</span>, index) + dfs(row, col-<span class="number">1</span>, index)</span><br><span class="line">            <span class="keyword">return</span> areas</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cal_sum</span>(<span class="params">row, col</span>):</span><br><span class="line">            area = <span class="number">0</span></span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]: <span class="comment"># 避免相同岛屿重复加</span></span><br><span class="line">                <span class="keyword">if</span> CheckBoundary(row+i, col+j) <span class="keyword">and</span> grid[row + i][col + j] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    area = area + dic[ grid[row + i][col + j] ]</span><br><span class="line">                    visited.add(grid[row + i][col + j])</span><br><span class="line">            <span class="keyword">return</span> area</span><br><span class="line">                    </span><br><span class="line">        </span><br><span class="line">        index = <span class="number">2</span></span><br><span class="line">        dic = &#123;<span class="number">0</span>: <span class="number">0</span>&#125; <span class="comment"># 颜色:面积</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                    dic[index] = dfs(row, col, index) <span class="comment"># 上色</span></span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        ans = <span class="built_in">max</span>(dic.values())</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">0</span>:</span><br><span class="line">                    temp = cal_sum(row, col) + <span class="number">1</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, temp)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="1730"><a href="#1730" class="headerlink" title="1730"></a>1730</h2><h2 id="490"><a href="#490" class="headerlink" title="490"></a>490</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C5-Prefix Sum</title>
      <link href="/2022/02/18/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C5-PrefixSum/"/>
      <url>/2022/02/18/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C5-PrefixSum/</url>
      
        <content type="html"><![CDATA[<h1 id="Prefix-Sum"><a href="#Prefix-Sum" class="headerlink" title="Prefix Sum"></a>Prefix Sum</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>Array</li><li>Matrix</li></ul><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>解法固定, 套用模板</li><li>关键词: <strong>continuous subarray</strong>, consecutive elements,  consecutive sequence, Subarray Sum</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>记录什么?  和对应的公式</li><li>起点 （初始化什么）</li></ul><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><ul><li><p>典型:  560, 523</p></li><li><p>Matrix: 304</p></li><li><p>（还没做）练习题: 128, 1248, 974, 325,  Matrix: 1314</p></li><li><p>（还没做）剑指: 66(题不好, 非常规prefix sum).</p></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="LC-560-Subarray-Sum-Equals-K"><a href="#LC-560-Subarray-Sum-Equals-K" class="headerlink" title="LC 560 - Subarray Sum Equals K"></a>LC 560 - Subarray Sum Equals K</h2><ul><li><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of subarrays whose sum equals to <code>k</code></em></p></li><li><p>key:  </p><ul><li>Hashmap: dic[prefix_sum] &#x3D; number of arrays, 存满足sum的array数量，不用存index（与position无关）</li><li>初始值 {0:1}</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dic = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125; <span class="comment"># dic[prefix_sum] = number of arrays</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sums += nums[i]</span><br><span class="line">            count += dic.get(sums-k,<span class="number">0</span>) <span class="comment"># # dict.get(key, default=None) 默认返回值</span></span><br><span class="line">            dic[sums] = dic.get(sums,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>(count)</span><br></pre></td></tr></table></figure><h2 id="LC-523-Continuous-Subarray-Sum"><a href="#LC-523-Continuous-Subarray-Sum" class="headerlink" title="LC 523 - Continuous Subarray Sum"></a>LC 523 - Continuous Subarray Sum</h2><ul><li>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if</em> <code>nums</code> <em>has a continuous subarray of size <strong>at least two</strong> whose elements sum up to a multiple of</em> <code>k</code><em>, or</em> <code>false</code> <em>otherwise</em>.<ul><li>return <code>true</code>, 不用返回count，不用存numbers； <strong>at least two</strong>，需要存储index –&gt; dic[prefix_sum] &#x3D; index</li><li>sum up to a multiple of* <code>k</code> : nums[i] % k &#x3D;&#x3D; nums[j] %k –&gt; nums[j] - nums[i] &#x3D; n*k</li></ul></li><li>key: 初始值 dic[prefix_sum] &#x3D; index {0, -1}</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkSubarraySum</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        dic = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125; <span class="comment"># dic[prefix_sum] = index</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            </span><br><span class="line">            sums = (sums + nums[i]) % k</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sums <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[sums] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i - dic[sums] &gt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="LC-304-Range-Sum-Query-2D"><a href="#LC-304-Range-Sum-Query-2D" class="headerlink" title="LC 304 - Range Sum Query 2D"></a>LC 304 - Range Sum Query 2D</h2><ul><li>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:<ul><li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li></ul></li><li>key: 矩阵和，数学解法<ul><li>注意扩展上边和左边为0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row, col = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        self.sums = [ [<span class="number">0</span>] * (col + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row + <span class="number">1</span>) ] <span class="comment"># 上和左要扩展一圈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col+<span class="number">1</span>):</span><br><span class="line">                self.sums[i][j] = self.sums[i][j-<span class="number">1</span>] + self.sums[i-<span class="number">1</span>][j] - self.sums[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1, col1, row2, col2</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.sums[row2 + <span class="number">1</span>][col1]-self.sums[row1][col2 + <span class="number">1</span>] + self.sums[row1][col1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C4-Heap</title>
      <link href="/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C4-Heap/"/>
      <url>/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C4-Heap/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><ul><li>Complete <a href="https://www.programiz.com/dsa/heap-sort">guide</a> with code</li></ul><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><ul><li>Physical structure: Array</li></ul><span id="more"></span><ul><li><p>Logic structure: complete binary tree.</p><img src="https://lh3.googleusercontent.com/pw/AM-JKLWjAFO77pgAh8ppF1JvwBisHva-1g_Q7s-jNLTYPJWVOPFL-NnAfVnNtnX5dBxYJ4aCLGIMcDxQUbIg3yzgZWZNJgjS3D_xiOliuNvJKtk44FjxUoUgK8XwFgG0s4ukcgVs1CpXJKntOZ5SZJ_mn8jc=w322-h248-no?authuser=2" style="zoom:33%;" /></li><li><p><strong>只是数组被看作complete binary tree 处理，本质还是对array进行操作</strong></p><ul><li>array index <code>i</code>, left child <code>2i+1</code>, right child <code>2i+2</code></li><li>array index <code>i</code>, parent index $\lfloor \frac{i-1}{2} \rfloor$</li></ul></li><li><p>Max and Min (all parents are greater or smaller than their children)</p><ul><li>Max heap, root node largest. </li><li>Min heap, root node smallest.</li></ul></li></ul><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLVWfK4STr75ifDy2o3ImjlQKiFUG1QykcXRdpyUGATPL95PfmmdSVnWnwjzEBjybarLUBMW0jsQZKKIUzqj9O-CLATpeEORV2dVD6F8zpVX1CzoAnJ5oOemhFcuvyI53UhQ6fh1rrvePcRA3tPslHJj=w1000-h599-no?authuser=0"></p><h2 id="Build-Heap"><a href="#Build-Heap" class="headerlink" title="Build Heap"></a>Build Heap</h2><ul><li><p>heapify on all non-leaf elements （recursion 自低向上）</p><ul><li><p>Heapify: 让parent大于左右孩子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="comment">// Find largest among root, left child and right child</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) </span><br><span class="line">  <span class="comment">// compelete binary tree 允许最底层 左为空，所以可能超界</span></span><br><span class="line">    largest = left;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">    largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap and continue heapifying if root is not largest</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">      swap(&amp;arr[i], &amp;arr[largest]);</span><br><span class="line">      heapify(arr, n, largest);</span><br><span class="line">      <span class="comment">// 让原来的root从顶到上找到它的位置，保证左右的sub-tree都是Max-Heap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>all non-leaf elements</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      heapify(arr, n, i);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Heap-Sort-（整理）"><a href="#Heap-Sort-（整理）" class="headerlink" title="Heap Sort （整理）"></a>Heap Sort （整理）</h2><ul><li><p>前提：Max - Heap</p></li><li><p>SWAP：</p><ul><li>让 root 和最后一个 element 交换</li><li>reduce heap size by 1 (即把最大元素从Heap中移出来)</li><li>Heapify the root element</li><li>Repeat</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  swap(&amp;arr[0], &amp;arr[i]);</span><br><span class="line">  </span><br><span class="line">  // Heapify root element to get highest element at root again</span><br><span class="line">  heapify(arr, i, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="D:\file\markdown图片\heap_sort.png" alt="procedures for implementing heap sort" style="zoom:50%;" /></li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    <span class="comment"># Find largest among root and children</span></span><br><span class="line">    largest = i</span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]:</span><br><span class="line">        largest = l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:</span><br><span class="line">        largest = r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If root is not largest, swap with largest and continue heapifying</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build max heap</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># Swap</span></span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Heapify root element</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line">heapSort(arr)</span><br><span class="line">n = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sorted array is&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &quot;</span> % arr[i], end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Heap-Sort-Complexity"><a href="#Heap-Sort-Complexity" class="headerlink" title="Heap Sort Complexity"></a>Heap Sort Complexity</h3><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(nlog n)</td></tr><tr><td align="left">Worst</td><td>O(nlog n)</td></tr><tr><td align="left">Average</td><td>O(nlog n)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(1)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>No</td></tr></tbody></table><ul><li><code>O(n log n)</code> upper bound on Heapsort’s running time and constant <code>O(1)</code> upper bound on its auxiliary storage.</li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul><li>Heap Complexity<ul><li>add: O(lgN)</li><li>remove: O(lgN)</li><li>search: O(N) (array)</li></ul></li><li>application<ul><li>keep extracting the smallest (or largest) element: Priority Queues</li></ul></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Leetcode: 347, 23, 295</p><h3 id="LC-347-Top-K-Frequent-Elements"><a href="#LC-347-Top-K-Frequent-Elements" class="headerlink" title="LC 347 - Top K Frequent Elements"></a>LC 347 - Top K Frequent Elements</h3><ul><li>use MinHeap instead of MaxHeap, so that the heap size can be maintained &lt;&#x3D; k：MinHeap 的 root 就是 第K大</li><li>维持一个size k MinHeap</li><li>若 <code>new element &gt; root,</code> <code>swap (new ele, root)</code> (kth will change by heapify)</li><li>若 <code>new element &lt; root</code>, 保持不变 （root仍是Kth）</li></ul><h3 id="LC-23-Merge-k-Sorted-Lists"><a href="#LC-23-Merge-k-Sorted-Lists" class="headerlink" title="LC 23 - Merge k Sorted Lists"></a>LC 23 - Merge k Sorted Lists</h3><p><a href="https://www.bilibili.com/video/BV1X4411u7xF?from=search&seid=11652588004630610482&spm_id_from=333.337.0.0">题解</a></p><ul><li>用 MinHeap 维持 每个链表头元素 <ul><li>Time: O(nlogk)    Space: O(K)</li></ul></li><li>MergeSort</li></ul><h3 id="LC-295-Find-Median-from-Data-Stream"><a href="#LC-295-Find-Median-from-Data-Stream" class="headerlink" title="LC 295 - Find Median from Data Stream"></a>LC 295 - Find Median from Data Stream</h3><ul><li>one MaxHeap and one MinHeap </li><li>key point: keep two heaps balanced</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://stackoverflow.com/questions/67390623/why-is-randomised-quicksort-considered-better-than-standard-quicksort">quicksort random better</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F3_Tree</title>
      <link href="/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F3-Tree/"/>
      <url>/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F3-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="F3-Tree"><a href="#F3-Tree" class="headerlink" title="F3 - Tree"></a>F3 - Tree</h2><h3 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h3><ul><li><p>fb 高频</p></li><li><p>思路：</p><span id="more"></span><ul><li>都在左边 – node.left</li><li>都在右边 – node.right</li><li>一左一右 – node</li></ul></li></ul><h4 id="LC-235-LCA-BST"><a href="#LC-235-LCA-BST" class="headerlink" title="LC 235 - LCA BST"></a>LC 235 - LCA BST</h4><ul><li><p>Lowest Common Ancestor of a Binary Search Tree</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    <span class="keyword">if</span>(p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val): <span class="comment"># 都在右边</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    <span class="keyword">elif</span>(p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val):</span><br><span class="line">        root = root.left;</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 左右各一个 -&gt; root为LCA</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ul><h4 id="LC-236-LCA-general"><a href="#LC-236-LCA-general" class="headerlink" title="LC 236 - LCA general"></a>LC 236 - LCA general</h4><ul><li>Lowest Common Ancestor of a Binary Tree</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L/R没有，返回R/L；LR，返回root</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="comment"># 左边没有 -&gt; 都在右边</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 左右各一个 -&gt; root为LCA</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><h4 id="LC-112-path-sum"><a href="#LC-112-path-sum" class="headerlink" title="LC 112 - path sum"></a>LC 112 - path sum</h4><ul><li>whether there is a root to leaf path in t such that the sum of path equals s</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root, targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure><h4 id="LC-101-Symmetric-Tree"><a href="#LC-101-Symmetric-Tree" class="headerlink" title="LC 101 - Symmetric Tree"></a>LC 101 - Symmetric Tree</h4><ul><li>whether it is symmetric around its center, i.e. each side mirrors the other</li><li>思路：<ul><li>root1.left &#x3D;&#x3D; root2.right &amp;&amp; root1.right &#x3D;&#x3D; root2.left</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">return</span> self.ismirror(root, root) <span class="comment"># 不写LR，避免None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ismirror</span>(<span class="params">self, root1, root2</span>):</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">None</span> <span class="keyword">and</span> root2 == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">None</span> <span class="keyword">and</span> root2 != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> root1.val == root2.val <span class="keyword">and</span> self.ismirror(root1.left, root2.right) <span class="keyword">and</span> self.ismirror(root1.right, root2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="LC-230-Kth-Smallest-in-BST"><a href="#LC-230-Kth-Smallest-in-BST" class="headerlink" title="LC 230 - Kth Smallest in BST"></a>LC 230 - Kth Smallest in BST</h4><ul><li>Given a binary search tree t, find the kth smallest element in it.</li><li>思路：inorder 遍历的第K个  (BST, 左儿子小 右儿子大)</li><li>难点：recursion怎么处理global k</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># recurssion</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root, k</span>):</span><br><span class="line">        self.k = k</span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        self.inorder(node.left);</span><br><span class="line">        self.k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.k:</span><br><span class="line">            self.ans = node.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.right)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># stack</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># inorder: left node right</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                    <span class="keyword">return</span> cur.val</span><br><span class="line">                cur = cur.right</span><br></pre></td></tr></table></figure><h4 id="LC-572-Subtree"><a href="#LC-572-Subtree" class="headerlink" title="LC 572 - Subtree"></a>LC 572 - Subtree</h4><ul><li>Subtree of Another Tree</li><li>递归递归</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, root, subRoot</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> subRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.identical(root, subRoot) <span class="keyword">or</span> self.isSubtree(root.left, subRoot) <span class="keyword">or</span> self.isSubtree(root.right, subRoot)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">identical</span>(<span class="params">self, r1, r2</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">or</span> <span class="keyword">not</span> r2:</span><br><span class="line">            <span class="keyword">return</span> r1 == r2 <span class="comment"># 同None真，一None假</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r1.val == r2.val <span class="keyword">and</span> self.identical(r1.left, r2.left) <span class="keyword">and</span> self.identical(r1.right, r2.right)</span><br></pre></td></tr></table></figure><h4 id="LC-257-Binary-Tree-Paths"><a href="#LC-257-Binary-Tree-Paths" class="headerlink" title="LC 257 - Binary Tree Paths"></a>LC 257 - Binary Tree Paths</h4><ul><li>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</li><li>关键：怎么存路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root</span>):</span><br><span class="line">        self.output = []</span><br><span class="line">        self.search(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.output</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, node, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="comment"># leaf</span></span><br><span class="line">            s += <span class="built_in">str</span>(node.val)</span><br><span class="line">            self.output.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        s += <span class="built_in">str</span>(node.val) + <span class="string">&#x27;-&gt;&#x27;</span></span><br><span class="line">        self.search(node.left, s)</span><br><span class="line">        self.search(node.right, s)</span><br></pre></td></tr></table></figure><ul><li><p>用 str 不需要 pop，因为 string 是primitive type，不是 object，值不会传入下一层</p></li><li><p>若是返回 list，那么加入后还需要删除 （是object）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans.append(node)</span><br><span class="line">self.search(node.left, ans)</span><br><span class="line">self.search(node.right, ans)</span><br><span class="line">ans.pop(node)</span><br></pre></td></tr></table></figure></li></ul><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><h4 id="LC-199-Right-Side-View"><a href="#LC-199-Right-Side-View" class="headerlink" title="LC 199 - Right Side View"></a>LC 199 - Right Side View</h4><ul><li>Binary Tree Right Side View</li><li>DFS key：<ul><li>从右向左</li><li>depth &#x3D;&#x3D; len(self.ans) 添加ans</li><li><code>if depth &lt; len(self.ans): return</code>  错误：如果左边比右边深，还需要向下搜索</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root</span>):</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.search(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, node, depth</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> depth == <span class="built_in">len</span>(self.ans): <span class="comment"># 当前层还未添加</span></span><br><span class="line">            self.ans.append(node.val)</span><br><span class="line">        self.search(node.right, depth+<span class="number">1</span>)</span><br><span class="line">        self.search(node.left, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>BFS key:<ul><li>deque</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            n = <span class="built_in">len</span>(deque)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>: <span class="comment"># 最后即是最右</span></span><br><span class="line">                    ans.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="？-LC-1120-subscribe"><a href="#？-LC-1120-subscribe" class="headerlink" title="？ LC 1120 - subscribe"></a>？ LC 1120 - subscribe</h4><h4 id="？-LC-297-Serialize-and-Deserialize-Binary-Tree"><a href="#？-LC-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="？ LC 297 - Serialize and Deserialize Binary Tree"></a>？ LC 297 - Serialize and Deserialize Binary Tree</h4><ul><li>思路：BFS</li></ul><h3 id="变形金刚"><a href="#变形金刚" class="headerlink" title="变形金刚"></a>变形金刚</h3><ul><li>直接再树上做变换</li></ul><h4 id="LC-226-Invert-Binary-Tree"><a href="#LC-226-Invert-Binary-Tree" class="headerlink" title="LC 226 - Invert Binary Tree"></a>LC 226 - Invert Binary Tree</h4><ul><li>以根为轴翻转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        root.left, root.right = root.right, root.left       </span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="LC-114-Flatten-Binary-Tree-to-Linked-List"><a href="#LC-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="LC 114 - Flatten Binary Tree to Linked List"></a>LC 114 - Flatten Binary Tree to Linked List</h4><img src="D:\file\markdown图片\image-20220313214916608.png" alt="image-20220313214916608" style="zoom:50%;" /><ul><li>preorder flatten</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 笨办法:空间消耗大</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        </span><br><span class="line">        temp = root.right</span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        root.right = temp</span><br><span class="line">        </span><br></pre></td></tr></table></figure><ul><li>思路: （右左中 - 从右到左 post order）<ul><li>把右子树放到左子树的最右边 （右边的一定比左边的位置后）</li><li>把左子树移动到右子树位置 （链表最终都在右儿子上），左儿子&#x3D;Null</li><li>update root.right</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root</span>):</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left: </span><br><span class="line">                predecessor = nxt = curr.left </span><br><span class="line">                <span class="keyword">while</span> predecessor.right:</span><br><span class="line">                    predecessor = predecessor.right</span><br><span class="line">                predecessor.right = curr.right </span><br><span class="line">                curr.left = <span class="literal">None</span></span><br><span class="line">                curr.right = nxt</span><br><span class="line">            curr = curr.right</span><br></pre></td></tr></table></figure><ul><li><p>思路：（preorder遍历，postorder处理）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        self.flatten(root.right);</span><br><span class="line">        self.flatten(root.left);</span><br><span class="line">        root.right = self.pre; <span class="comment"># self.pre子树已经flattern了</span></span><br><span class="line">        root.left = <span class="literal">None</span>;</span><br><span class="line">        self.pre = root;</span><br></pre></td></tr></table></figure></li></ul><h4 id="？-LC-426-subscribe"><a href="#？-LC-426-subscribe" class="headerlink" title="？ LC 426 - subscribe"></a>？ LC 426 - subscribe</h4><h4 id="？-LC-156-subscribe"><a href="#？-LC-156-subscribe" class="headerlink" title="？ LC 156 - subscribe"></a>？ LC 156 - subscribe</h4><h1 id="遍历模板"><a href="#遍历模板" class="headerlink" title="遍历模板"></a>遍历模板</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="Recurssion"><a href="#Recurssion" class="headerlink" title="Recurssion"></a>Recurssion</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(root.left)</span><br><span class="line">    <span class="built_in">print</span>(root.data)</span><br><span class="line">    inorder(root.right)</span><br></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ul><li><p>inorder</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stack = deque()</span><br><span class="line">curr = root</span><br><span class="line"> </span><br><span class="line"><span class="comment"># if the current node is None and the stack is also empty, we are done</span></span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">or</span> curr:</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> curr:</span><br><span class="line">        stack.append(curr)</span><br><span class="line">        curr = curr.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># otherwise, if the current node is None, pop an element from the stack,</span></span><br><span class="line">        curr = stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(curr.data, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        curr = curr.right</span><br></pre></td></tr></table></figure></li><li><p>preorder - (node - left - right)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack = [root]</span><br><span class="line"><span class="keyword">while</span> stack():</span><br><span class="line">    cur = stack.pop()</span><br><span class="line">    ans.add(cur.val)</span><br><span class="line">    <span class="keyword">if</span> cur.right:</span><br><span class="line">        stack.append(cur.right)</span><br><span class="line">    <span class="keyword">if</span> cur.left:</span><br><span class="line">        stack.append(cur.left)</span><br></pre></td></tr></table></figure></li><li><p>postorder (left right node)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">ans = deque()</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">if</span> root:</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">stack.append(root)</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    cur = stack.pop()</span><br><span class="line">    ans.appendleft(cur.val)</span><br><span class="line">    <span class="keyword">if</span> cur.left:</span><br><span class="line">        stack.append(cur.left)</span><br><span class="line">    <span class="keyword">if</span> cur.right:</span><br><span class="line">        stack.append(cur.right)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_depth</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    q = [root]</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">            <span class="keyword">if</span> q[i].left:</span><br><span class="line">                temp.append(q[i].left)</span><br><span class="line">            <span class="keyword">if</span> q[i].right:</span><br><span class="line">                temp.append(q[i].right)</span><br><span class="line">        q = temp[:]</span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C3-Tree</title>
      <link href="/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C3-Tree/"/>
      <url>/2022/02/12/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C3-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><h3 id="Node-Class"><a href="#Node-Class" class="headerlink" title="Node Class"></a>Node Class</h3><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> key; </span><br><span class="line">    Node left, right; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> item)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        key = item; </span><br><span class="line">        left = right = <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="Binary-Tree-Class"><a href="#Binary-Tree-Class" class="headerlink" title="Binary Tree Class"></a>Binary Tree Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// Root of Binary Tree </span></span><br><span class="line">    Node root; </span><br><span class="line">  </span><br><span class="line">    BinaryTree() </span><br><span class="line">    &#123; </span><br><span class="line">        root = <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Build-the-Tree"><a href="#Build-the-Tree" class="headerlink" title="Build the Tree"></a>Build the Tree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(); </span><br><span class="line">tree.root = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>); </span><br><span class="line">tree.root.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>); </span><br><span class="line">tree.root.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>); </span><br><span class="line">tree.root.left.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>); </span><br><span class="line">tree.root.left.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="Traverse"><a href="#Traverse" class="headerlink" title="Traverse"></a>Traverse</h2><ul><li>Depth (Breath) First Search</li></ul><p><img src="D:\file\markdown图片\image-20220225173200561.png" alt="image-20220225173200561"></p><p>虽然常见的Traverse方法是以上几种, 其实不仅限于上面几种. 以上的DFS都是从左边开始的, DFS还可以从右边开始. </p><p>Code这里有两种方法, 一种是Recursion, 另一种是Iteration, Recursion就不说了, 背的滚瓜烂熟, 说一下Iteration:</p><ul><li>跟Recursion不同, Iteration的逻辑没有统一性, 有好几种方法, 但无论如何, 没有任何一种方法可以把三者完全统一, 下面用的是postorder和preorder一套逻辑, inorder是另一套自己的逻辑. </li><li>postOrder的Iteration是最容易理解的, 理解之后看preOrder, 注意要用LinkedList. </li><li>inOrder是自己一套逻辑, 其实这个逻辑已经跟recursion差不多了, 理解有难度的话, 就背下来吧. </li><li><strong>Iteration三方法都是需要熟练掌握背诵的</strong>. </li><li>Iteration的优势就是在recursion题写不出来的时候, Iteration基于其可控性也许能够帮到你.</li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given a binary tree, print its nodes in inorder:left-node-right */</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printInorder</span><span class="params">(Node node)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* first recur on left child */</span></span><br><span class="line">    printInorder(node.left); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* then print the data of node */</span></span><br><span class="line">    System.out.print(node.key + <span class="string">&quot; &quot;</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* now recur on right child */</span></span><br><span class="line">    printInorder(node.right); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python - inorder DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    inorder(root.left)</span><br><span class="line">    <span class="built_in">print</span>(root.data, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    inorder(root.right)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Construct the following tree</span></span><br><span class="line"><span class="string">               1</span></span><br><span class="line"><span class="string">             /   \</span></span><br><span class="line"><span class="string">            /     \</span></span><br><span class="line"><span class="string">           2       3</span></span><br><span class="line"><span class="string">          /      /   \</span></span><br><span class="line"><span class="string">         /      /     \</span></span><br><span class="line"><span class="string">        4      5       6</span></span><br><span class="line"><span class="string">              / \</span></span><br><span class="line"><span class="string">             /   \</span></span><br><span class="line"><span class="string">            7     8</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">    root = Node(<span class="number">1</span>)</span><br><span class="line">    root.left = Node(<span class="number">2</span>)</span><br><span class="line">    root.right = Node(<span class="number">3</span>)</span><br><span class="line">    root.left.left = Node(<span class="number">4</span>)</span><br><span class="line">    root.right.left = Node(<span class="number">5</span>)</span><br><span class="line">    root.right.right = Node(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = Node(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = Node(<span class="number">8</span>)</span><br><span class="line"> </span><br><span class="line">    inorder(root)</span><br></pre></td></tr></table></figure><h4 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h4><p>inorder - (left - node - right)</p><img src="D:\file\markdown图片\image-20220225173424943.png" alt="image-20220225173424943" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Pseudocode</span></span><br><span class="line">s —&gt; empty stack</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> s.isEmpty() <span class="keyword">or</span> node != null)</span><br><span class="line">  <span class="keyword">if</span> (node != null)  <span class="comment"># 向左搜索</span></span><br><span class="line">    s.push(node)</span><br><span class="line">    node —&gt; node.left</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    node —&gt; s.pop()</span><br><span class="line">    visit(node)</span><br><span class="line">    node —&gt; node.right</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    TreeNode curr=root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr=curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr=stack.pop();</span><br><span class="line">        res.add(curr.val);</span><br><span class="line">        curr=curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorderIterative</span>(<span class="params">root</span>):</span><br><span class="line">    </span><br><span class="line">    stack = deque()</span><br><span class="line">    curr = root</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># if the current node is None and the stack is also empty, we are done</span></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> curr:</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> curr:</span><br><span class="line">            stack.append(curr)</span><br><span class="line">            curr = curr.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># otherwise, if the current node is None, pop an element from the stack,</span></span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="built_in">print</span>(curr.data, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">            curr = curr.right</span><br></pre></td></tr></table></figure><p>preorder - (node - left - right)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        ans.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostOrder - (left - right - node)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="comment">// 这里非常重要要用LinkedList, 因为下面要用addFirst. </span></span><br><span class="line">LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">ans.addFirst(cur.val);  <span class="comment">// 加在开头</span></span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(cur.right);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h3 id="BFS-with-level"><a href="#BFS-with-level" class="headerlink" title="BFS with level"></a>BFS with level</h3><ul><li>BFS 有大概3-4种不同的流派和写法, 目前看了很多还是觉得这个最好.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// depth用来track 整个tree的深度, 如果不需要这个量, 可不用. </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// n用来track 每一层的node数. </span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;n ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">thisNode</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span>(thisNode.left!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(thisNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(thisNode.right!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(thisNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// n=q.size = 每层的node数</span></span><br><span class="line">            n = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><ul><li>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</li></ul><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLU0tyNnSzNLcRCQXTE-9FPddX49SrLzoY17Oci5hZGUj2lrzhmAPp6mIXDnxVXnBVSy29t_UkYLPXPE9mDqqxQGO0XXSuhtmYvQBiei8bpSMWe76dPjdX1N5WLPCInD43lHtQQNk0Ytr3CUIeDNhDiI=w342-h221-no?authuser=2"></p><h3 id="Full-Binary-Tree"><a href="#Full-Binary-Tree" class="headerlink" title="Full Binary Tree"></a>Full Binary Tree</h3><ul><li>A full binary tree (sometimes proper binary tree or 2-tree) is a tree in which every node other than the leaves has two children.</li></ul><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLVH3C5BPTQXvefIRKc8jmQrhQ_gfhogQsRev2PQ1vuId77KME6EtZ9MKAAuka57iQjES4ReTSljycc-QZxYdPNcNx0S9lDudC2L7WPIDfUShwG_a8bvkNZScwum6HVzJCQl2hkfJxhqMvFJUAhWVsS_=w320-h300-no?authuser=2"></p><h3 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a>Complete Binary Tree</h3><ul><li>A complete binary tree is a binary tree in which all the levels are completely filled except possibly the lowest one, which is filled from the left.</li></ul><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLWjAFO77pgAh8ppF1JvwBisHva-1g_Q7s-jNLTYPJWVOPFL-NnAfVnNtnX5dBxYJ4aCLGIMcDxQUbIg3yzgZWZNJgjS3D_xiOliuNvJKtk44FjxUoUgK8XwFgG0s4ukcgVs1CpXJKntOZ5SZJ_mn8jc=w322-h248-no?authuser=2"></p><h3 id="Binary-Search-Tree-BST"><a href="#Binary-Search-Tree-BST" class="headerlink" title="Binary Search Tree - BST"></a>Binary Search Tree - BST</h3><ul><li><p>A tree is considered a binary search tree (BST) if for each of its nodes the following is true:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and the right subtrees must also be binary search trees.</li></ul></li></ul><p><img src="D:\file\markdown图片\Insert-into-BST.png"></p><ul><li>技巧, BST的traverse不用上面提到的DFS 和 BFS, 可以直接比大小. </li><li>题目: 235 (LCA)</li></ul><h3 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h3><p>不需要掌握. </p><ul><li>AVL tree is a self-balancing binary search tree.</li></ul><p><img src="D:\file\markdown图片\AVL-Tree1.jpg"></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h3><p>不需要掌握. </p><ul><li>B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree generalizes the binary search tree, allowing for nodes with more than two children.</li></ul><p><img src="D:\file\markdown图片\Insertion+in+B-Trees+Insertion+in+a+B-tree+of+odd+order.jpg"></p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>下节讲</p><p><img src="D:\file\markdown图片\binaryheap.png"></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>以后讲</p><h2 id="技巧总结"><a href="#技巧总结" class="headerlink" title="技巧总结"></a>技巧总结</h2><ul><li>Tree这一块美国很喜欢考. 因为有点小难度, 又不至于太难为人, 代码量也不大. </li><li>这一块是值得刷熟练度的. 如果对递归不是很擅长的话, 建议集中多刷50道Tree.  但没有必要刷难题偏题, 简单中等即可. 不会考太难.</li></ul><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><ul><li>掌握一套基本的模板.</li></ul><h3 id="返回子和返回根"><a href="#返回子和返回根" class="headerlink" title="返回子和返回根"></a>返回子和返回根</h3><p>一般的递归分两种情况, 返回子和返回root. </p><ul><li>整个tree做变化的需要返回root. 像下面的变形金刚问题都是需要返回root. </li><li>求某个子的, 比如求lowest common ancestor则需要返回子.  子的返回方式是每一层赋值. 返回root的方式是每一层不赋值, 如下, LC235题答案.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val&lt;root.val)&#123;</span><br><span class="line">    <span class="comment">// 这里加root = 就可以把底层我们需要的子每一层返回上去, 涂抹掉原本根的值, 最后结果是我们寻找的子. </span></span><br><span class="line">    <span class="comment">// 如果不进行涂抹的话, 最后只会返回最高层的root. </span></span><br><span class="line">        root = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.val&gt;root.val &amp;&amp; q.val&gt;root.val)&#123;</span><br><span class="line">        root = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试不同-Traverse"><a href="#尝试不同-Traverse" class="headerlink" title="尝试不同 Traverse"></a>尝试不同 Traverse</h3><ul><li>一般的题考虑用四种Traverse 方法来解. 如果没有思路的话, 就四种都试一遍. <ul><li>先处理根用 preorder</li><li>先处理子用 postorder, </li><li>BST的话, 从下到上是inorder, 从上到下不用order 直接判断即可.  </li><li>BFS 很明显, 一般不需要判断.</li></ul></li></ul><h2 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h2><h3 id="LC112-hasPathWithGivenSum"><a href="#LC112-hasPathWithGivenSum" class="headerlink" title="LC112_hasPathWithGivenSum"></a>LC112_hasPathWithGivenSum</h3><blockquote><p>Given a binary tree t and an integer s, determine whether there is a root to leaf path in t such that the sum of vertex values equals s.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasPathWithGivenSum</span><span class="params">(Tree&lt;Integer&gt; t, <span class="type">int</span> s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If just one of left or right was null, then it was not a child node and false can be returned safely</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//If this is a child AND sum is input, then we have a path</span></span><br><span class="line">    <span class="keyword">if</span>(t.left == <span class="literal">null</span> &amp;&amp; t.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (s == t.value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hasPathWithGivenSum(t.left, s-t.value) || hasPathWithGivenSum(t.right, s-t.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC101-isTreeSymmetric"><a href="#LC101-isTreeSymmetric" class="headerlink" title="LC101_isTreeSymmetric"></a>LC101_isTreeSymmetric</h3><blockquote><p>Given a binary tree t, determine whether it is symmetric around its center, i.e. each side mirrors the other.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Binary trees are already defined with this interface:</span></span><br><span class="line"><span class="comment">// class Tree&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">//   Tree(T x) &#123;</span></span><br><span class="line"><span class="comment">//     value = x;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   T value;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; left;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; right;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTreeSymmetric</span><span class="params">(Tree&lt;Integer&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(Tree&lt;Integer&gt; root1, Tree&lt;Integer&gt; root2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//If both trees are empty, then they are mirror images </span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For two trees to be mirror images, the following three </span></span><br><span class="line">    <span class="comment">//     conditions must be true </span></span><br><span class="line">    <span class="comment">//     1 - Their root node&#x27;s key must be same </span></span><br><span class="line">    <span class="comment">//     2 - left subtree of left tree and right subtree </span></span><br><span class="line">    <span class="comment">//       of the right tree have to be mirror images </span></span><br><span class="line">    <span class="comment">//     3 - right subtree of left tree and left subtree </span></span><br><span class="line">    <span class="comment">//        of right tree have to be mirror images </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>  (root1.value.equals(root2.value))</span><br><span class="line">        <span class="comment">// Java比较能用equals都用equals, 之前跑不过就是因为没用equals. </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMirror(root1.left, root2.right) &amp;&amp; isMirror(root1.right, root2.left);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//If none of these requirement were met, return false. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC230-kthSmallestInBST"><a href="#LC230-kthSmallestInBST" class="headerlink" title="LC230_kthSmallestInBST"></a>LC230_kthSmallestInBST</h3><ul><li>Given a binary search tree t, find the kth smallest element in it.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Binary trees are already defined with this interface:</span></span><br><span class="line"><span class="comment">// class Tree&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">//   Tree(T x) &#123;</span></span><br><span class="line"><span class="comment">//     value = x;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   T value;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; left;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; right;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> answer, k;</span><br><span class="line"><span class="comment">// Recursion 之中, 重要的参数尽量放在 recursion之外, 不然recursion之间的参数极易发生混乱. </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kthSmallestInBST</span><span class="params">(Tree&lt;Integer&gt; t, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">    inorderTraverse(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorderTraverse</span><span class="params">(Tree&lt;Integer&gt; t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inorderTraverse(t.left);</span><br><span class="line"></span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        answer = t.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inorderTraverse(t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><br><br></p><h3 id="LC572-isSubTree"><a href="#LC572-isSubTree" class="headerlink" title="LC572 isSubTree"></a>LC572 isSubTree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Binary trees are already defined with this interface:</span></span><br><span class="line"><span class="comment">// class Tree&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">//   Tree(T x) &#123;</span></span><br><span class="line"><span class="comment">//     value = x;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   T value;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; left;</span></span><br><span class="line"><span class="comment">//   Tree&lt;T&gt; right;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有简单办法, Traverse 整个 Tree, 然后在check每个Node是否相同. </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(Tree&lt;Integer&gt; T, Tree&lt;Integer&gt; S)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* base cases */</span></span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* Check the tree with root as current node */</span></span><br><span class="line">    <span class="keyword">if</span> (areIdentical(T, S))  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* If the tree with root as current node doesn&#x27;t match then </span></span><br><span class="line"><span class="comment">       try left and right subtrees one by one */</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(T.left, S) || isSubtree(T.right, S); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">areIdentical</span><span class="params">(Tree&lt;Integer&gt; root1, Tree&lt;Integer&gt; root2)</span>  </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* base cases */</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the data of both roots is same and data of left and right </span></span><br><span class="line"><span class="comment">        subtrees are also same */</span></span><br><span class="line">    <span class="keyword">return</span> (root1.value.equals(root2.value)</span><br><span class="line">            &amp;&amp; areIdentical(root1.left, root2.left) </span><br><span class="line">            &amp;&amp; areIdentical(root1.right, root2.right)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="LC257-Binary-Tree-Paths"><a href="#LC257-Binary-Tree-Paths" class="headerlink" title="LC257_Binary Tree Paths"></a>LC257_Binary Tree Paths</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; output = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        preOrder(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right ==<span class="literal">null</span>)&#123;</span><br><span class="line">            s+=root.val;</span><br><span class="line">            output.add(s);</span><br><span class="line">            <span class="comment">//sb.deleteCharAt(sb.length()-1);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=(root.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        preOrder(root.left, s);</span><br><span class="line">        preOrder(root.right,s);</span><br><span class="line">        <span class="comment">//sb.deleteCharAt(sb.length()-1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#LC235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="LC235_Lowest Common Ancestor of a Binary Search Tree"></a>LC235_Lowest Common Ancestor of a Binary Search Tree</h3><ul><li>235和236 都是 FB高频.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value of p</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pVal</span> <span class="operator">=</span> p.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value of q;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qVal</span> <span class="operator">=</span> q.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start from the root node of the tree</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse the tree</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Value of ancestor/parent node.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> node.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) &#123;</span><br><span class="line">                <span class="comment">// If both p and q are greater than parent</span></span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) &#123;</span><br><span class="line">                <span class="comment">// If both p and q are lesser than parent</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We have found the split point, i.e. the LCA node.</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等难度"><a href="#中等难度" class="headerlink" title="中等难度"></a>中等难度</h2><h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h3><ul><li>BFS vs DFS <strong>重要, DFS+层数</strong></li></ul><h3 id="LC1120-Maximum-Average-Subtree"><a href="#LC1120-Maximum-Average-Subtree" class="headerlink" title="LC1120_Maximum Average Subtree"></a>LC1120_Maximum Average Subtree</h3><p>照标准答案改的, 标准答案太啰嗦了.  <strong>重点在于新建 class 记录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// for each node in the tree, we will maintain three values</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">// count of nodes in the subtree</span></span><br><span class="line">        <span class="type">int</span> nodeCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sum of values in the subtree</span></span><br><span class="line">        <span class="type">int</span> valueSum;</span><br><span class="line"></span><br><span class="line">        State(<span class="type">int</span> nodes, <span class="type">int</span> sum) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nodeCount = nodes;</span><br><span class="line">            <span class="built_in">this</span>.valueSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> maxAverage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maximumAverageSubtree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxAverage(root);</span><br><span class="line">        <span class="keyword">return</span> maxAverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State <span class="title function_">maxAverage</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">State</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// postorder traversal, solve for both child nodes first.</span></span><br><span class="line">        <span class="type">State</span> <span class="variable">left</span> <span class="operator">=</span> maxAverage(root.left);</span><br><span class="line">        <span class="type">State</span> <span class="variable">right</span> <span class="operator">=</span> maxAverage(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now find nodeCount, valueSum and maxAverage for current node `root`</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeCount</span> <span class="operator">=</span> left.nodeCount + right.nodeCount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left.valueSum + right.valueSum + root.val;</span><br><span class="line">        maxAverage = Math.max((<span class="number">1.0</span> * (sum)) / nodeCount, maxAverage); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">State</span>(nodeCount, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h3><ul><li>FB 高频, 插旗子.</li></ul><h3 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h3><h2 id="变形金刚"><a href="#变形金刚" class="headerlink" title="变形金刚"></a>变形金刚</h2><p>变形金刚有以下几个特点: </p><ul><li>不会构建新的Tree, 而是在原有tree的基础之上扭来扭去造成变化 </li><li>难点不是扭, 而是如何处理扭加递归.  正是因为这两样结合, 所以这一系列照比上面单纯的递归要难很多, 通常是medium.</li></ul><h3 id="LC-226-Invert-Binary-Tree"><a href="#LC-226-Invert-Binary-Tree" class="headerlink" title="LC_226 Invert Binary Tree"></a>LC_226 Invert Binary Tree</h3><p>原题<a href="https://leetcode.com/problems/invert-binary-tree/">在此</a></p><p>原题缺乏描述. 其实这个invert是镜像invert, 也就是镜子里面原tree的样子.  这个解法很精简, 用递归, 用的是postorder traverse. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个其实就是postOrder, 关键在于想明白其实是先把子换了, 最后换parent. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面两行对调也没有关系. 无论left 和right 哪个在前都不影响. </span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC-114-Flatten-Binary-Tree-to-Linked-List"><a href="#LC-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="LC_114 Flatten Binary Tree to Linked List"></a>LC_114 Flatten Binary Tree to Linked List</h3><h3 id="LC-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List"><a href="#LC-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List" class="headerlink" title="LC_426 Convert Binary Search Tree to Sorted Doubly Linked List"></a>LC_426 Convert Binary Search Tree to Sorted Doubly Linked List</h3><h3 id="LC-156-Binary-Tree-Upside-Down"><a href="#LC-156-Binary-Tree-Upside-Down" class="headerlink" title="LC_156 Binary Tree Upside Down"></a>LC_156 Binary Tree Upside Down</h3><p>跟上面114一样是一道扭来扭去的题目.  整理的答案在下面, 看code是看不懂的, 要看上面的注释,很清晰: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        When we turn a simple tree upside down: </span></span><br><span class="line"><span class="comment">                Root                Left</span></span><br><span class="line"><span class="comment">                /  \                /  \</span></span><br><span class="line"><span class="comment">             Left  Right        Right  Root</span></span><br><span class="line"><span class="comment">        So recursively go to the most left child. Since that will be our new root. And we populate the that child all the way up. So it&#x27;s visiting root -&gt; root.left -&gt; root.left.left -&gt; root.left.left.left....</span></span><br><span class="line"><span class="comment">        And when its at current root, we make root.left.left = right. root.left.right = root. (We are basically assign left and right child to root.left - new root). Then delete root.left and root.right</span></span><br><span class="line"><span class="comment">           1</span></span><br><span class="line"><span class="comment">          / \   root=2 now            root=1 now</span></span><br><span class="line"><span class="comment">         2   3    ----&gt;      4   1   ------------&gt;   4</span></span><br><span class="line"><span class="comment">        / \                 / \ / \                 / \</span></span><br><span class="line"><span class="comment">       4   5               5   2   3               5   2</span></span><br><span class="line"><span class="comment">            (deleted 2&#x27;s original 4 and 5)            / \</span></span><br><span class="line"><span class="comment">                                                     3   1(deleted 1&#x27;s original 2 and 3)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">upsideDownBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> upsideDownBinaryTree(root.left);</span><br><span class="line">        root.left.left = root.right;</span><br><span class="line">        root.left.right = root;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试最重要的是什么"><a href="#面试最重要的是什么" class="headerlink" title="面试最重要的是什么?"></a>面试最重要的是什么?</h2><ul><li>运气 &gt; 情报 &gt; Behavior &gt; coding</li><li>情报<ul><li>Facebook  第一轮 phone screen, 只有一个人.  第二轮, 三轮, 一轮 behavior, 两轮 coding</li><li>怎么面? 白板面试, 还是写code? 什么语言? 几道题? </li><li>面试范围. 考不考 dp?</li></ul></li><li>behavior</li><li>coding<ul><li>刷公司特定高频高频</li><li>解题思路</li><li>需要背的知识点</li><li>刷 common 高频</li><li>Object-oriented design</li></ul></li></ul><h2 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a>Time and Space Complexity</h2><ul><li>Time complexity: O(n) n as total nodes of the tree.</li><li>Space complexity: O(n)<ul><li>recursion space complexity O(n). Draw back:</li><li><strong>Recursion</strong> consumes stack <strong>space</strong>. Every recursive method call produces a new instance of the method, one with a new set of local variables. The total stack space used depends upon the level of nesting of the recursion process, and the number of local variables and parameters.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F2_指针和滑动窗口</title>
      <link href="/2021/11/29/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F2-pointers/"/>
      <url>/2021/11/29/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F2-pointers/</url>
      
        <content type="html"><![CDATA[<h1 id="F2-指针和滑动窗口"><a href="#F2-指针和滑动窗口" class="headerlink" title="F2_指针和滑动窗口"></a>F2_指针和滑动窗口</h1><h2 id="双向指针"><a href="#双向指针" class="headerlink" title="双向指针"></a>双向指针</h2><blockquote><p>关键：游标卡尺 （找到移动条件），一般只关注端点，不关注区间element</p><p>条件：一般 l &lt; r</p></blockquote><h3 id="LC167-two-sum"><a href="#LC167-two-sum" class="headerlink" title="LC167 - two sum"></a>LC167 - two sum</h3><ul><li>题目：two sum - 给定单调不减数组和c，找到一组（a,b）使得 a+b &#x3D; c</li></ul><span id="more"></span><ul><li>low, high 指针<ul><li>(low + high) &gt; c –&gt; high –</li><li>(low + high) &gt; c –&gt; low ++</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers, target</span>):</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="built_in">sum</span> = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                <span class="keyword">return</span> [l+<span class="number">1</span>,r+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="LC15-three-sum"><a href="#LC15-three-sum" class="headerlink" title="LC15 - three sum"></a>LC15 - three sum</h3><ul><li>题目：3 sum - 给定数组，找到所有不重复三元组[a,b,c]，a+b+c &#x3D; 0</li><li>sort</li><li>遍历 num[i] &lt;&#x3D; 0<ul><li>找 a+b &#x3D; -c (同two sum)</li><li>存（a,b,c）</li><li>(不重复) num[low] &#x3D;&#x3D; num[low-1]，low ++</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">or</span> (i&gt;<span class="number">0</span>  <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]): <span class="comment"># 去重 + 简化</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append((nums[i], nums[l], nums[r]))</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:  <span class="comment"># 去重, 出现nums[i+1] 一定要考虑边界</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r-<span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span>; r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="LC11-with-most-water"><a href="#LC11-with-most-water" class="headerlink" title="LC11 - with most water"></a>LC11 - with most water</h3><ul><li>题目：with most water - min(height[left], height[right])*(right-left))</li><li>贪心思想</li><li>左右指针 (保留高的墙壁)<ul><li>ans &#x3D; max(max, Math.min(height[left], height[right])*(right-left))</li><li>height[left]&gt;height[right] –&gt; right–</li><li>height[left]&lt;height[right] –&gt; left ++</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span> , <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[r],height[l])*(r-l))</span><br><span class="line">            <span class="keyword">if</span> height[l]&gt;height[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="LC581-最短未排序区间"><a href="#LC581-最短未排序区间" class="headerlink" title="LC581 - 最短未排序区间"></a>LC581 - 最短未排序区间</h3><ul><li>题目: 给定数组，找到最短[a,b], 使得[a,b] 排序后，整个数组都是有序的 O(n)</li><li>易错：不能只找拐点</li><li>思路1：<ul><li>遍历两边：从前（后）到后（前），找到拐点a（b）</li><li>遍历: [a,b] 找打 max，min</li><li>遍历: [0,a] 找min ；[b,end] 找 max</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20191122233425943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9taWNoYWVsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />+ 思路2：排序，再对比第一个不相等元素 （nlogn）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findUnsortedSubarray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[l] &lt;= nums[l+<span class="number">1</span>]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&gt;<span class="number">0</span> <span class="keyword">and</span> nums[r-<span class="number">1</span>]&lt;=nums[r]:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        n_min,n_max = nums[l],nums[l]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l,r+<span class="number">1</span>):</span><br><span class="line">            n_min = <span class="built_in">min</span>(n_min,nums[i])</span><br><span class="line">            n_max = <span class="built_in">max</span>(n_max,nums[i])</span><br><span class="line">        l_s, r_s = l, r</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; n_min:</span><br><span class="line">                l_s = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>,r,-<span class="number">1</span>): <span class="comment"># 倒着循环</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; n_max:</span><br><span class="line">                r_s = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> r_s+<span class="number">1</span>-l_s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findUnsortedSubarray</span>(<span class="params">self, nums</span>):</span><br><span class="line">    </span><br><span class="line">        a = nums[:] <span class="comment"># 复制元素，不然指向同一地址！！</span></span><br><span class="line">        a.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != a[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != a[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> j-i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="同向指针"><a href="#同向指针" class="headerlink" title="同向指针"></a>同向指针</h2><blockquote><p>like sliding window, 关注区间的端点和中间的element</p><p>HashMap: 只关心count or pos, 与顺序无关</p></blockquote><h3 id="LC438-find-anagrams"><a href="#LC438-find-anagrams" class="headerlink" title="LC438 - find anagrams"></a>LC438 - find anagrams</h3><ul><li>题目：Find All Anagrams in a String</li><li>anagrams – 存出现频率即可</li><li>比较Hashmap (python: dict) &#x2F; set<ul><li>key: value &#x3D;&#x3D;0 和 不存在key, 再Hashmap中是不同的<ul><li>解决方法1：最开始就初始化全部为“0”</li><li>解决方法2：若key对应value为0，删除key: value</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s, p</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">len</span>(p):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s_count, p_count = [<span class="number">0</span>] * <span class="number">26</span>, [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> p:</span><br><span class="line">            p_count[<span class="built_in">ord</span>(ch)%<span class="number">26</span>] += <span class="number">1</span> <span class="comment"># 使用set，instead of dict/Hashmap</span></span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): <span class="comment"># 区间长度给定，单指针就行</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(p):</span><br><span class="line">                s_count[<span class="built_in">ord</span>(s[i])%<span class="number">26</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s_count == p_count:</span><br><span class="line">                ans.append(i - <span class="built_in">len</span>(p))</span><br><span class="line">            s_count[<span class="built_in">ord</span>(s[i])%<span class="number">26</span>] += <span class="number">1</span></span><br><span class="line">            s_count[<span class="built_in">ord</span>(s[i-<span class="built_in">len</span>(p)])%<span class="number">26</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s_count == p_count:</span><br><span class="line">            ans.append(<span class="built_in">len</span>(s)-<span class="built_in">len</span>(p))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="LC03-最短不重复区间"><a href="#LC03-最短不重复区间" class="headerlink" title="LC03 - 最短不重复区间"></a>LC03 - 最短不重复区间</h3><ul><li>题目：find the length of the longest substring without repeating characters</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针 若x在set中，则left左移至原 position x +1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        ans, l ,r = <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span></span><br><span class="line">        string_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">while</span> s[r] <span class="keyword">in</span> string_set:</span><br><span class="line">                string_set.remove(s[l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            string_set.add(s[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r-l)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hashmap  key(字母):value(上一次出现位置)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        ans, l, r = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        s_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s_dict.get(s[r]) != <span class="literal">None</span>: <span class="comment"># 注意 None 和 0</span></span><br><span class="line">                l = <span class="built_in">max</span>(l, s_dict[s[r]]+<span class="number">1</span>) <span class="comment"># 有重复的最远位置</span></span><br><span class="line">            s_dict[s[r]] = r</span><br><span class="line">            r += <span class="number">1</span> <span class="comment"># 左开右闭</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r-l)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        ans, last = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            last = <span class="built_in">max</span>(hashmap.get(<span class="built_in">ord</span>(s[i]), -<span class="number">1</span>), last)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - last)</span><br><span class="line">            hashmap[<span class="built_in">ord</span>(s[i])] = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h2><blockquote><p>链表不能定位，用快慢针保持结尾和所求位置的关系</p></blockquote><h3 id="L876-链表中点"><a href="#L876-链表中点" class="headerlink" title="L876 链表中点"></a>L876 链表中点</h3><ul><li><p>Middle of the Linked List</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head</span>):</span><br><span class="line">        </span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>: <span class="comment"># 注意条件</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></li></ul><h3 id="LC19-删除链表倒数Kth"><a href="#LC19-删除链表倒数Kth" class="headerlink" title="LC19 删除链表倒数Kth"></a>LC19 删除链表倒数Kth</h3><ul><li><p>Remove Nth Node From End of List</p><ul><li><strong>dummy head</strong>：避免删除第一个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head) <span class="comment"># 防止第一个元素被移除</span></span><br><span class="line">        slow, fast = dummy, dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动窗口-deque"><a href="#滑动窗口-deque" class="headerlink" title="滑动窗口 &#x2F; deque"></a>滑动窗口 &#x2F; deque</h2><h3 id="LC239-Sliding-Window-Maximum-deque"><a href="#LC239-Sliding-Window-Maximum-deque" class="headerlink" title="LC239 Sliding Window Maximum (deque)"></a>LC239 Sliding Window Maximum (deque)</h3><ul><li><p>给定nums以及窗口大小K，返回每一个滑动窗口中的最大值[]</p></li><li><p>Deque</p><ul><li><p>queue 后面进，前面出；stack 后面进，后面出</p></li><li><p>deque 前后都可以进出</p></li><li><p><img src="D:\file\markdown图片\image-20220225154819522.png" alt="image-20220225154819522"></p></li></ul></li><li><p>算法：</p><ul><li>记录max下标，存入deque</li><li>窗口移动时<ul><li>判断是否出界，若出界则popleft</li><li>num[i] &gt; deque[num[-1]]: deque.pop() –&gt; 后面比前面大，那么前面的不会再用到了</li></ul></li><li>重点：<ul><li>deque[num[0]] 一定是窗口中的max</li><li>dq 中的element一定是降序排列</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        dq = deque() <span class="comment"># 存的index</span></span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> dq <span class="keyword">and</span> i - dq[<span class="number">0</span>] == k: <span class="comment"># 区间长度大于k：i -dq[0] + 1 &gt; k 同i-dq[0] == k</span></span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[-<span class="number">1</span>]] &lt;= nums[i]: <span class="comment"># h</span></span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                ans.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul><h3 id="LC-992-Subarrays-with-K-Different-Integers"><a href="#LC-992-Subarrays-with-K-Different-Integers" class="headerlink" title="LC 992 Subarrays with K Different Integers"></a>LC 992 Subarrays with K Different Integers</h3><ul><li><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>good subarrays</strong> of</em> <code>nums</code>.</p><p>A <strong>good array</strong> is an array where the number of different integers in that array is exactly <code>k</code>.</p></li><li><p>算法：</p><ul><li>滑动窗口找 atmost K –&gt; exactlk k &#x3D; atmost(nums, k) - atmost(nums, k-1)</li><li>对于新元素nums[i]<ul><li>前面已经出现过，则可以再组成 i - left + 1 个子序列</li><li>未出现，则加入；若size超过K，则 left ++</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写的太丑了 不想改了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">atmost</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:  <span class="comment"># ans default = 1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left, ans = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    count = <span class="built_in">dict</span>()</span><br><span class="line">    count[nums[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> count:</span><br><span class="line">            count[nums[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[nums[i]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> <span class="built_in">len</span>(count) &gt; k):</span><br><span class="line">            <span class="keyword">if</span> count[nums[left]] == <span class="number">1</span>:</span><br><span class="line">                count.pop(nums[left])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[nums[left]] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        ans += i - left + <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraysWithKDistinct</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> atmost(nums, k) - atmost(nums, k-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h2><h3 id="LC26-删除重复元素"><a href="#LC26-删除重复元素" class="headerlink" title="LC26 删除重复元素"></a>LC26 删除重复元素</h3><ul><li><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array">Remove Duplicates from Sorted Array</a></p><ul><li>easy: 双指针</li></ul></li></ul><h3 id="LC42-trapping-water-rain"><a href="#LC42-trapping-water-rain" class="headerlink" title="LC42 trapping water rain"></a>LC42 trapping water rain</h3><ul><li><p><a href="https://leetcode.com/problems/trapping-rain-water">Trapping Rain Water</a></p></li><li><p>可以存水的条件：height[i] &lt; min(leftmax,rightmax)</p></li><li><p>法一：O(n) O(n)</p><ul><li>遍历找leftmax rightmax</li><li>遍历算ans</li></ul></li><li><p>法二：O(n) O(1)</p><ul><li>左右指针</li><li>存水取决于min(leftmax,rightmax)<ul><li>leftmax &lt; rightmax –&gt; left ++</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        leftmax, rightmax = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            leftmax[i] = <span class="built_in">max</span>(height[i-<span class="number">1</span>], leftmax[i-<span class="number">1</span>])</span><br><span class="line">            rightmax[n-<span class="number">1</span>-i] = <span class="built_in">max</span>(height[n-i], rightmax[n-i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(leftmax[i], rightmax[i]) - height[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        leftmax, rightmax = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r: <span class="comment"># 注意边界条件</span></span><br><span class="line">            <span class="keyword">if</span> leftmax &lt; rightmax:</span><br><span class="line">                ans += <span class="built_in">max</span>(leftmax - height[l], <span class="number">0</span>)</span><br><span class="line">                leftmax = <span class="built_in">max</span>(leftmax, height[l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += <span class="built_in">max</span>(rightmax - height[r], <span class="number">0</span>)</span><br><span class="line">                rightmax = <span class="built_in">max</span>(rightmax, height[r])</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul><h3 id="LC763-Partition-Labels"><a href="#LC763-Partition-Labels" class="headerlink" title="LC763 Partition Labels"></a>LC763 Partition Labels</h3><ul><li><p>partition the string into as many parts as possible so that each letter appears in at most one part.</p></li><li><p>第一次做错误原因：直接achor  &#x3D; pos[s[archor]]+1, 只关注了开头，忽略了子段中间的信息（中间存在字符的最后pos &gt; 头的最后pos）</p></li><li><p>算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s</span>):</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        pos = &#123;ch: last_pos  <span class="keyword">for</span> last_pos,ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)&#125; <span class="comment"># emunerate 返回 index, element</span></span><br><span class="line">        anchor, far = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            far = <span class="built_in">max</span>(far, pos[ch])</span><br><span class="line">            <span class="keyword">if</span> index == far:  <span class="comment"># 注意条件</span></span><br><span class="line">                ans.append(index - anchor + <span class="number">1</span>)</span><br><span class="line">                anchor = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C2_指针和滑动窗口</title>
      <link href="/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C2-pointers/"/>
      <url>/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C2-pointers/</url>
      
        <content type="html"><![CDATA[<h2 id="相向指针"><a href="#相向指针" class="headerlink" title="相向指针"></a>相向指针</h2><ul><li>和Sliding Window的区别, 就是双指针, 只取两个pointer 的位置, 但 Sliding window 会考虑他们之间所有的值.</li></ul><span id="more"></span><h3 id="Two-Sum-II-Input-array-is-sorted-LC-167"><a href="#Two-Sum-II-Input-array-is-sorted-LC-167" class="headerlink" title="Two Sum II - Input array is sorted LC_167"></a>Two Sum II - Input array is sorted LC_167</h3><p><strong>Problem Description</strong></p><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">LC167</a></p><p><strong>Code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (high &gt; low)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[low] + numbers[high]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;low+<span class="number">1</span>, high+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[low] + numbers[high] &gt; target)&#123;</span><br><span class="line">                high --;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3Sums-LC15"><a href="#3Sums-LC15" class="headerlink" title="3Sums LC15"></a>3Sums LC15</h3><p>其实就是按照2SumII的双指针去进行的, 区别是要引入第三个量, 做一些相应的调整. 其实也就是用第三个量卡一下而已. 增加一层维度. </p><p>需要注意的是, 下面加注释的部分, 其他看leetcode标准答案就好, 有动画, 说的很详细了, 不再赘述.</p><p><strong>code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; output;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// nums[i]&lt;=0 的这个条件是因为, 双指针是向右卡的, low 和high的相应值都大于i. </span></span><br><span class="line">        <span class="comment">// 所以一旦大于0就不可能有解了, 没必要继续traverse下去. </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i]&lt;=<span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || nums[i]!=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="comment">// 上面这个if只有一个目的, 就是去重. 去重的原因是这道题的条件不让重复. </span></span><br><span class="line">               <span class="comment">// 去重的原理是之前的sort, 因为sort, 所以只要查相邻是不是重复即可. </span></span><br><span class="line">                twoSum(nums, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//System.out.println(nums[i]);</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//System.out.println(curr + &quot; &quot; + nums[low] + &quot; &quot; + nums[high]);</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> curr + nums[low] + nums[high];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                low ++;</span><br><span class="line">                <span class="comment">//System.out.println(nums[low]);</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[low++]);</span><br><span class="line">                list.add(nums[high--]);</span><br><span class="line">                output.add(list);</span><br><span class="line">                <span class="comment">// 这个while loop是twoSumII里没有的. </span></span><br><span class="line">                <span class="comment">// 加这个的原因是, 这道题不是唯一解的, 就算两个指针卡到了, 也可能往下继续卡有其他解. </span></span><br><span class="line">                <span class="comment">// 之前twoSumII没有加这个while loop调整指针继续往下卡的原因是twoSumII的题就设定是单解. </span></span><br><span class="line">                <span class="keyword">while</span>(low&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[low] == nums[low-<span class="number">1</span>])&#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Container-With-Most-Water-LC-011"><a href="#Container-With-Most-Water-LC-011" class="headerlink" title="Container With Most Water LC_011"></a>Container With Most Water LC_011</h3><p><strong>Problem Description</strong></p><p>题目不放了, 因为需要看图才能看懂, 直接去<a href="https://leetcode.com/problems/container-with-most-water/">LeetCode</a>上面看吧. </p><p><strong>Algorithm</strong></p><p>这道题我拿来首先想到的就是dynamic programming, 但越想越觉得不符合dynamic的求和原则, 因为需要考虑之前的所有边.   </p><p>算法是Sliding Window 这一次的游标卡尺是从首尾两端开始卡, 慢慢往里面收. 由于题目的特殊性而使用木桶原理.  </p><p><strong>这种特殊的题目没什么好说的, 唯有刷脸.</strong></p><br><p><strong>Code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>, right = height.length -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[left], height[right])*(right-left));</span><br><span class="line">            <span class="comment">//System.out.println(left + &quot; , &quot; + right + &quot; , &quot; + maxArea);</span></span><br><span class="line">            <span class="keyword">if</span>(height[left]&gt;height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同向指针"><a href="#同向指针" class="headerlink" title="同向指针"></a>同向指针</h2><h3 id="LC581-Shortest-Unsorted-Continuous-Subarray"><a href="#LC581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="LC581_Shortest Unsorted Continuous Subarray"></a>LC581_Shortest Unsorted Continuous Subarray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer low;</span><br><span class="line">    <span class="keyword">private</span> Integer high;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="type">int</span>[] sNums = nums.clone();</span><br><span class="line">        Arrays.sort(sNums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=sNums[i])&#123;</span><br><span class="line">                low = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=low+<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;sNums[i])&#123;</span><br><span class="line">                high = i;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> high-low+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Time complexity : O(nlogn). Sorting takes  nlogn time.</p></li><li><p>Space complexity : O(n). We are making n copy of original array.</p></li></ul><h3 id="LC438-Find-All-Anagrams-in-a-String"><a href="#LC438-Find-All-Anagrams-in-a-String" class="headerlink" title="LC438_Find All Anagrams in a String"></a>LC438_Find All Anagrams in a String</h3><p>这道题挺有意思的, 不算特别吧. 思路其实想想也不难, 看答案不到10分钟就能懂.  这道题关键的是这个思路, <strong>HashMap是可以比较的</strong>, 有了这个思路之后很多题都可以利用这个思路比,<strong>尤其是那种乱序的比较, 只比较元素不比较顺序的, 都可以用这个思路</strong>: </p><ul><li>key 和 value完全一样的两个HashMap就是完全相同的, </li><li>key, value&#x3D;0 和 没有这个key和value是两回事, 不相等. hashmap, key &#x3D; a, value &#x3D; 0. 和 hashmap b, 没有key &#x3D; a 这是两回事.</li></ul><p>官方答案太啰嗦, 自己改了改, 放在下面. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> s.length(), np = p.length();</span><br><span class="line">    <span class="keyword">if</span> (ns &lt; np) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; pMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    Map&lt;Character, Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">// build reference hashmap using string p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: p.toCharArray())&#123;</span><br><span class="line">        pMap.put(c, pMap.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// sliding window on the string s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns; ++i) &#123;</span><br><span class="line">      <span class="comment">// add one more letter </span></span><br><span class="line">      <span class="comment">// on the right side of the window</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">      sMap.put(c, sMap.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// remove one letter </span></span><br><span class="line">      <span class="comment">// from the left side of the window</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= np) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i - np);</span><br><span class="line">        <span class="keyword">if</span> (sMap.get(ch) == <span class="number">1</span>) &#123;</span><br><span class="line">          sMap.remove(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          sMap.put(ch, sMap.get(ch) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// compare hashmap in the sliding window</span></span><br><span class="line">      <span class="comment">// with the reference hashmap</span></span><br><span class="line">      <span class="keyword">if</span> (pMap.equals(sMap)) &#123;</span><br><span class="line">        output.add(i - np + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Longest-Substring-Without-Repeating-Characters-LC-03"><a href="#Longest-Substring-Without-Repeating-Characters-LC-03" class="headerlink" title="Longest Substring Without Repeating Characters LC_03"></a>Longest Substring Without Repeating Characters LC_03</h3><p><strong>Problem Description</strong></p><p>Given a string s, find the length of the longest substring without repeating characters.</p><p>Example 1:</p><blockquote><p>Input: s &#x3D; “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p></blockquote><p>Example 2:</p><blockquote><p>Input: s &#x3D; “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p></blockquote><p><strong>Code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> answer=<span class="number">0</span>, i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!hs.contains(s.charAt(j)))</span><br><span class="line">            &#123;</span><br><span class="line">                hs.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(hs.size()&gt;answer)</span><br><span class="line">                &#123;</span><br><span class="line">                    answer = hs.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hs.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Algorithm</strong></p><p>其实这个算法并不难, 反而比较实际, 容易理解.  把Set hs想象成一把游标卡尺, 卡尺的左端是i, 右端是j.<br>假设我们有一个String  ABCDAE</p><p>从A点出发, i和j都在0, 也就是A, 只要下一个char没有重复, 游标卡尺的右端就不断往下一个char走. 如上面的例子, 游标卡尺走到ABCDA, j &#x3D; 4的时候会停住.  这个时候从A点出发的不重复subString已经到了Max. 这个时候把尺子右端不动, 把卡尺左端往后挪一位. 我们得到 BCDA. 之后下一位还是不重复的E, 再挪右端j, 左端i不动. 得到BCDAE. 这个过程中keep tracking 卡尺的max长度. 最后得到答案5. </p><p>两点: </p><ol><li><p>一开始会考虑要不要向前track, 其实想一下完全没有必要. 这个理解就是和DP是一样的, 因为之前的元素已经被卡尺求过了, 没有必要向前. 所有的subString都是向后track. </p></li><li><p>一开始是在想是不是要在每个字母上卡一下, 是不是一旦出现了重复元素之后, 就立刻要把尺子收紧把左端右端合在一起然后重新测量, 会把else写成这样: </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    i++;</span><br><span class="line">    j=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 举个例子: ABCBD 这个, 一开始尺子卡在ABC, 然后在B发现重复, 尺子收起来, 从B(i&#x3D;1)开始重新卡. 我会这么想, 其实这么想也比较直观. </p><p> 其实实际上没有必要. <strong>关键在于这个尺子里面的元素是不可重复的</strong>, 也就是说尺子内部的元素是绝对干净的. 这个时候没有必要收尺子, 尺子左端已经在正确的位置, 只要继续挪动右端就可以了.</p></li></ol><p>还有一些更快的解法, 游标卡尺加上hashmap的解法.  <strong>用hashmap记录位置, 加上一个尺子收紧的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        Map&lt;Character, Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">output</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(ch))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastPosition</span> <span class="operator">=</span> hm.get(ch);</span><br><span class="line">                <span class="keyword">if</span>(j&lt;lastPosition) &#123;</span><br><span class="line">                    j = lastPosition;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output = Math.max(output, i - j + <span class="number">1</span>);</span><br><span class="line">            hm.put(ch, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h2><ul><li>用法比较单一, Linkedlist, 提取index</li></ul><h3 id="LC876-Middle-of-the-Linked-List"><a href="#LC876-Middle-of-the-Linked-List" class="headerlink" title="LC876_Middle of the Linked List"></a>LC876_Middle of the Linked List</h3><p>一道很纯粹的快慢针问题. 快针是慢针速度的两倍.  纯粹的太简单了.  有兴趣可以看一下148题, 比这个稍微复杂一些, 需要处理edge case. </p><p><strong>code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC19-Remove-Nth-Node-From-End-of-List"><a href="#LC19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="LC19_Remove Nth Node From End of List"></a>LC19_Remove Nth Node From End of List</h3><p>一道在LinkedList上的快慢指针. 一开始看很简单, 其实不然. 思路很简单, 但具体edge case很特殊, 不好处理. 需要考虑的是只有一个元素和remove head的情况, 所以加装这个dummy head. </p><p><strong>19题, 1721题, 1474 这三道题同宗同源</strong>. 其中最难的是19题, 需要考虑的稍微多一些.  如果要刷的话, 就刷19题吧. </p><p><strong>code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"> <span class="comment">// 这个dummyHead不是没有意义的. 加装dummyHead的意义是为了处理remove head和只有一个元素的情况. </span></span><br><span class="line"> <span class="comment">// 这个算法必须有三个元素的时候才有用.  加装dummyhead之后, 在有一个元素的情况下是, dummyHead, head, null(可以允许一个null)</span></span><br><span class="line"> <span class="comment">// 本身思路并不难, edge case 很不好处理. </span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种解法"><a href="#两种解法" class="headerlink" title="两种解法"></a>两种解法</h2><ul><li>Deque: 前后都可以出. </li><li>index 指针, <strong>它更聪明, 一定更省空间</strong>.</li></ul><h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h3><p><strong>重点.</strong> 很巧妙直接用deque解的方法. 在加入之中进行删减, 造成第一个元素永远为最大的情况.  难点在于用deque去记录index, 而不是元素本身.</p><p>下面的答案是从标准答案来的, 改成了自己的习惯, 并且加了注释, 看五分钟就能看懂.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    Deque&lt;Integer&gt; deq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// remove indexes of elements not from sliding window</span></span><br><span class="line">        <span class="comment">// Keep only the indexes of elements from the current sliding window.</span></span><br><span class="line">        <span class="comment">// 其实也就是查一下第一个元素是不是我们需要剔除的边际元素. </span></span><br><span class="line">        <span class="keyword">if</span>(!deq.isEmpty() &amp;&amp; deq.getFirst() == i-k)</span><br><span class="line">            deq.removeFirst();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remove from deq indexes of all elements </span></span><br><span class="line">        <span class="comment">// which are smaller than current element nums[i], since they will not be the maximum ones.</span></span><br><span class="line">        <span class="comment">// 因为这些数都比nums[i] 小, 而且都在nums[i] 左边, 所以没必要留着, 因为window是从左往右的, 他们一定会在nums[i]之前被刷掉. </span></span><br><span class="line">        <span class="keyword">while</span>(!deq.isEmpty() &amp;&amp; nums[i]&gt;nums[deq.getLast()])</span><br><span class="line">            deq.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// edge cases. </span></span><br><span class="line">        <span class="keyword">if</span>(n*k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// First initial phase. from 0 to k. </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            clean(i,k);</span><br><span class="line">            deq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        output[<span class="number">0</span>] = nums[deq.getFirst()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;n; i++)&#123;</span><br><span class="line">            clean(i,k);</span><br><span class="line">            deq.addLast(i);</span><br><span class="line">            <span class="comment">// The first element of deque is the our max value. </span></span><br><span class="line">            <span class="comment">// deq的第一个就是max.</span></span><br><span class="line">            output[i-k+<span class="number">1</span>] = nums[deq.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="992-Subarrays-with-K-Different-Integers"><a href="#992-Subarrays-with-K-Different-Integers" class="headerlink" title="992. Subarrays with K Different Integers"></a>992. Subarrays with K Different Integers</h3><p>一道比较喜欢的滑动窗口难题. 滑动窗口可以考的很难. 下面这道就是. </p><p><strong>下面这个用HashMap统计个数的技巧需要掌握</strong>, 最难的点在于理解为什么 output+&#x3D; i-j+1; 其实就是拆分的排列组合公式, 解释放在了最下面. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果要算exact k 的话, 就用 至多 k 减去至多 k - 1. </span></span><br><span class="line">        <span class="comment">// 这步不难理解, 稍微想一会儿就能想通. </span></span><br><span class="line">        <span class="keyword">return</span> atMost(nums, k) - atMost(nums, k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">atMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// hm用来统计个数,  key 是 int in nums,  val 是 key int 出现的frequency. </span></span><br><span class="line">        Map&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i, j 是两个滑动窗口, 保证 i j 之间的differnt 不能超过k 个. </span></span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>, output = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 统计个数, 出现就放进 hm 里</span></span><br><span class="line">            hm.put(nums[i], hm.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果hm size  大于 k, i-j之间的different  int  个数已经大于 k. </span></span><br><span class="line">            <span class="comment">// 这是我们需要滑动 j 向右, 减少 different  int  个数. </span></span><br><span class="line">            <span class="keyword">while</span>(hm.size() &gt; k)&#123;</span><br><span class="line">                <span class="comment">// 将当前 j上的数字移除 hm</span></span><br><span class="line">                hm.put(nums[j], hm.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(hm.get(nums[j]) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// if val小于等于 0, 说明这个 数已经不存在了, 移除 hashmap. </span></span><br><span class="line">                    hm.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++; <span class="comment">// j向右一位. </span></span><br><span class="line">            &#125;</span><br><span class="line">            output += i - j + <span class="number">1</span>;  <span class="comment">// 这一步是排列组合公式来的. 需要看下面的更多解释. </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">More explanation on output += i - j + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">step <span class="number">1.</span> find all subarrays that has most K odd <span class="title function_">number</span>   <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ...K)</span></span><br><span class="line">step <span class="number">2.</span> find all subarrays that has most K-<span class="number">1</span> odd <span class="title function_">number</span>  <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...K-<span class="number">1</span>)</span></span><br><span class="line">step <span class="number">3.</span> find step <span class="number">1</span> minus step <span class="number">2</span> will result in subarrays only has K odd numbers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">example</span><br><span class="line">arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">K=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">when K=<span class="number">2</span></span><br><span class="line">i           j-i+<span class="number">1</span>          contiguous subarray</span><br><span class="line"><span class="number">0</span>            <span class="number">1</span>               [<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span>            <span class="number">2</span>               [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>] </span><br><span class="line"><span class="number">2</span>            <span class="number">3</span>               [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span>            <span class="number">4</span>               [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>]</span><br><span class="line"><span class="number">4</span>            <span class="number">4</span>               [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>]</span><br><span class="line">total                         <span class="number">14</span> subarrays</span><br><span class="line"></span><br><span class="line">when K=<span class="number">1</span></span><br><span class="line">i           j-i+<span class="number">1</span>          contiguous subarray</span><br><span class="line"><span class="number">0</span>            <span class="number">1</span>               [<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span>            <span class="number">2</span>               [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>] </span><br><span class="line"><span class="number">2</span>            <span class="number">3</span>               [<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span>            <span class="number">4</span>               [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>]</span><br><span class="line"><span class="number">4</span>            <span class="number">4</span>               [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>]</span><br><span class="line">total                        <span class="number">10</span> subarrays</span><br><span class="line"></span><br><span class="line">when K=<span class="number">2</span> minus when K=<span class="number">1</span> is <span class="number">4</span> subarrays</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><ul><li>基本上是Array, 可以说SlidingWindow一定是array.  然后twoPointer不一定. </li><li>不能存在求和关系. </li><li>一段区间之内, 产生连续关系的时候, 使用SlidingWindow</li></ul><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li>针是不是碰到了边界.  j&lt;n</li><li>i &lt; j </li><li>同向情况: 可以需要考虑的一个因素, 每一次, j必往右走一步, i走不走, 情况判断. 这样可以尽量保证, j在i右边.</li></ul><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>HashMap常用, 记录 freq, 记录 index</li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li><strong>3</strong>, 11, 167, 15, <strong>438</strong>, 581, 26, 42(难), 763</li><li>876, 19, <strong>239</strong>, 992. 239题可以自己写一下指针的解法版本. </li><li><strong>215</strong> QuickSelect 重要.</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>如果没有会员的话, 可以跟我借个leetcode账号.</li></ul><h2 id="Commitment"><a href="#Commitment" class="headerlink" title="Commitment"></a>Commitment</h2><ul><li>我三个月之内是可以教的.  但是假设就算我哪天真不想了, 我有契约精神, 我至少会告知你之后, 再教三节课. </li><li>你的话, 不想学随时可以跟我说.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F1_Sort</title>
      <link href="/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F1-sort/"/>
      <url>/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-F1-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="F1-搜索"><a href="#F1-搜索" class="headerlink" title="F1_搜索"></a>F1_搜索</h1><blockquote><p>LC912 排序</p></blockquote><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul><li>bubble sort: 遍历n-1次，每一次两两比较swap<ul><li>O(n^2)  – O(n)</li></ul></li><li>selection sort: 遍历n-1次，每一次找最小放在前面<ul><li>O(n^2)  – O(n)</li></ul></li></ul><span id="more"></span><ul><li>insertion sort: 从头到尾遍历，每一次将第i个元素放到[0, i-1]中合适的位置<ul><li>O(n^2)  – O(n)</li></ul></li></ul><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BubbleSort</span>(<span class="params">nums</span>): <span class="comment"># 两两比较，大的放后面</span></span><br><span class="line">  n = <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># swap = 0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>-i):</span><br><span class="line">      <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">        nums[j+<span class="number">1</span>], nums[j] = nums[j], nums[j+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># swap = 1</span></span><br><span class="line">    <span class="comment"># if not swap:</span></span><br><span class="line">      <span class="comment"># break</span></span><br><span class="line">  <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>Worst O(n^2^); Best O(n)</li></ul><h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SelectionSort</span>(<span class="params">nums</span>): <span class="comment"># 每次选一个最小的放在前面</span></span><br><span class="line">  n = <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    min_index = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[min_index]:</span><br><span class="line">        min_index = j</span><br><span class="line">    nums[i], nums[min_index] = nums[min_index], nums[i]</span><br><span class="line">  <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>Worst O(n^2^); Best O(n^2^)</li><li>应用：Top K elements; The Kth Largest</li></ul><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertionSort</span>(<span class="params">nums</span>):  <span class="comment"># 将第i个元素插入到[0~i]中合适的位置</span></span><br><span class="line">  n = <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    pos = i-<span class="number">1</span></span><br><span class="line">    cur = nums[i]</span><br><span class="line">    <span class="keyword">while</span> pos&gt;=<span class="number">0</span>  <span class="keyword">and</span> nums[pos] &gt; cur:</span><br><span class="line">      nums[pos+<span class="number">1</span>] = nums[pos] <span class="comment"># 位置要移动</span></span><br><span class="line">      pos -= <span class="number">1</span></span><br><span class="line">    nums[pos+<span class="number">1</span>] = cur</span><br><span class="line">  <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>Worst O(n^2^); Best O(n)</li></ul><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">nums, left, right</span>): <span class="comment"># 存left, right避开了开空间</span></span><br><span class="line">  <span class="keyword">if</span>(left &lt; right):</span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    MergeSort(nums, left, mid)</span><br><span class="line">    MergeSort(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">    Merge(nums, left, mid, right)</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">nums, left, mid, right</span>):</span><br><span class="line">  i = left</span><br><span class="line">  j = mid + <span class="number">1</span></span><br><span class="line">  temp = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[j]:</span><br><span class="line">      temp.append(nums[i])</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      temp.append(nums[j])</span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> i&lt;= mid:</span><br><span class="line">    temp.append(nums[i])</span><br><span class="line">    i += <span class="number">1</span> </span><br><span class="line">  <span class="keyword">while</span> j&lt;=right:</span><br><span class="line">    temp.append(nums[j])</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  nums[left:right+<span class="number">1</span>] = temp</span><br></pre></td></tr></table></figure><ul><li><strong>没有worst case和best case，时间复杂度稳定是O(nlgn)，但是合并的时候需要开空间</strong></li></ul><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">nums, left, right</span>):</span><br><span class="line">  <span class="keyword">if</span> left &lt; right:</span><br><span class="line">      pivot = partition(nums, left, right)</span><br><span class="line">      QuickSort(nums, left, pivot-<span class="number">1</span>)</span><br><span class="line">      QuickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, left, right</span>):</span><br><span class="line">  pivot_val = nums[right]</span><br><span class="line">  cur = left     </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; pivot_val:</span><br><span class="line">      nums[i], nums[cur] = nums[cur], nums[i]</span><br><span class="line">      cur += <span class="number">1</span></span><br><span class="line">  nums[cur], nums[right] = nums[right], nums[cur]</span><br><span class="line">  <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><ul><li><strong>Time: not stable. averge O(nlogn), worst scenario O(n^2).  但是省空间 O(1) space.</strong></li><li>应用：the kTh largest element</li><li>和 归并排序 比较<ul><li>devide后就已经是顺序的，无需conquer</li><li>pivot选取随机，导致左右分布不均匀</li><li>Merge: stable O(nlogn). require O(n) space.</li><li>not stable. averge O(nlogn), worst scenario O(n^2). O(1) space.</li></ul></li></ul><h3 id="LC215-Kth-Largest-Element-in-an-Array"><a href="#LC215-Kth-Largest-Element-in-an-Array" class="headerlink" title="LC215 - Kth Largest Element in an Array"></a>LC215 - Kth Largest Element in an Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">    </span><br><span class="line">        n = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        self.QuickSort(nums, <span class="number">0</span>, n, k-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">self, nums, left, right, k</span>):</span><br><span class="line">        <span class="keyword">if</span>(left &lt;  right):</span><br><span class="line">            pivot = self.Partition(nums, left, right)</span><br><span class="line">            <span class="keyword">if</span> pivot == k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> pivot &lt; k:</span><br><span class="line">                self.QuickSort(nums, pivot+<span class="number">1</span>, right, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.QuickSort(nums, left, pivot-<span class="number">1</span>, k)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Partition</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        cur = left</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; pivot:</span><br><span class="line">                nums[i], nums[cur] = nums[cur], nums[i]</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        nums[cur], nums[right] = nums[right], nums[cur]</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">        </span><br></pre></td></tr></table></figure><ul><li><p>其他解法 Minheap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        heap = nums[:k]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">                heapq.heappush(heap, nums[i])      </span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C1_Sort</title>
      <link href="/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C1-sort/"/>
      <url>/2021/11/28/0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8A%E8%AF%BE/0-algorithm-C1-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><ul><li>高频：宽度优先搜索（BFS），深度优先搜索（DFS），二分法（Binary Search），双指针（2 Pointer），堆、栈、队列、哈希表（Heap，Stack，Heap，HashMap&#x2F;HashSet），前缀和（Prefix Sum），链表（LinkedList），二叉树（Binary Tree），二叉搜索树（Binary Search Tree），快速排序与归并排序（Quick Sort&#x2F; Merge Sort）</li></ul><span id="more"></span><ul><li>中频：动态规划（DP），扫描线（Sweep Line），字典树（Trie），并查集（Union Find），单调栈与单调队列（Monotone Stack&#x2F; Queue），TreeMap等</li><li>低频：Dijkstra，树状数组，线段树，最小生成树等</li></ul><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><p>最基本的brutal force sorting.   就是从头到尾一遍一遍的过n次, 如果前一个比后一个大就swap,直到没有swap为止. </p><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><ol><li>Repeatedly swapping the adjacent elements if they are in wrong order.</li><li>First go from 0 to n-1, keep swaping so we have the largest element in the end. </li><li>Then go from 0 to n-2, and so on. </li><li>If no swap happens, then break loop. It will take at most n-1 times to traverse the array.</li></ol><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLW4sN6VLP6SZBnhwEHNDHmF94FoT7vPHD4_cY7bNUR5OQ1Qus-cOvonFuololtvlz8rE_WDwJFsn8yZXVxTgFdLFjSD2K-GjF9i7BkI0Pw6dSJFbjczYAcwvon1omvTdHvVoR2qqmVg9P0hcgOD38e0=w901-h535-no?authuser=0"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An optimized version of Bubble Sort </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, j, temp; </span><br><span class="line">    <span class="type">boolean</span> swapped; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)  </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">// 此处用n-1次for loop可以保证最后一定sorting, 也可以用while(!swap), 效果是一样的</span></span><br><span class="line">        swapped = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)  </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])  </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// swap arr[j] and arr[j+1] </span></span><br><span class="line">                temp = arr[j]; </span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]; </span><br><span class="line">                arr[j + <span class="number">1</span>] = temp; </span><br><span class="line">                swapped = <span class="literal">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// IF no two elements were  </span></span><br><span class="line">        <span class="comment">// swapped by inner loop, then break </span></span><br><span class="line">        <span class="comment">// 这是一个optimal的算法, 也可以不用swapped这个量, 直接走n次, 能保证最后一定是sorted. </span></span><br><span class="line">        <span class="keyword">if</span> (swapped == <span class="literal">false</span>) </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Space-and-Time-Complexity"><a href="#Space-and-Time-Complexity" class="headerlink" title="Space and Time Complexity"></a>Space and Time Complexity</h3><ul><li><p>Worst and Average Case Time Complexity: O(n^2). Worst case occurs when array is reverse sorted.</p></li><li><p>Best Case Time Complexity: O(n). Best case occurs when array is already sorted.</p></li></ul><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p>Repeatedly finding the minimum element from unsorted part and putting it at the beginning.</p><p>应用: </p><ul><li>the kth largest element. </li><li>Top k elements, </li><li><strong>any order</strong></li></ul><p><img src="https://miro.medium.com/max/700/0*c6jNITnQ_jIvCk-3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, j, min_idx; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// One by one move boundary of unsorted subarray </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Find the minimum element in unsorted array </span></span><br><span class="line">        min_idx = i; </span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) </span><br><span class="line">            min_idx = j; </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Swap the found minimum element with the first </span></span><br><span class="line">        <span class="comment">// element </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min_idx]; </span><br><span class="line">        arr[min_idx] = arr[i]; </span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Space-and-Time-Complexity-1"><a href="#Space-and-Time-Complexity-1" class="headerlink" title="Space and Time Complexity"></a>Space and Time Complexity</h3><ul><li><p>Worst and Average Case Time Complexity: O(n^2). Worst case occurs when array is reverse sorted.</p></li><li><p>Best Case Time Complexity: O(n). Best case occurs when array is already sorted.</p></li></ul><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p>也很brutal, 整个array从头到尾刷一遍, 如果后一个比前一个小, 就用while loop跟上一个比较往前挪, 直到挪到适当的位置为止. </p><h3 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>To sort an array of size n in ascending order:  </p><ol><li>Iterate from arr[1] to arr[n] over the array.</li><li>Compare the current element (key) to its predecessor.</li><li>If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.</li></ol><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* Move elements of arr[0..i-1], that are </span></span><br><span class="line"><span class="comment">           greater than key, to one position ahead </span></span><br><span class="line"><span class="comment">           of their current position */</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123; </span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]; </span><br><span class="line">            j = j - <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        arr[j + <span class="number">1</span>] = key; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Space-and-Time-Complexity-2"><a href="#Space-and-Time-Complexity-2" class="headerlink" title="Space and Time Complexity"></a>Space and Time Complexity</h3><ul><li><p>Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.</p></li><li><p>Best Case Time Complexity: O(n^2^). Best case occurs when array is already sorted.</p></li></ul><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><ul><li>和QuickSort 同为最常见最好用的sorting. 对unsorted list通杀. 优点就是快. 对LinkedList也能用, LC148.</li><li>Merge Sort is a Divide and Conquer algorithm.</li><li>简单来说就是用二分法把这个array不断二分, 最后分成一个数的时候再互相比较重新拼回去. </li><li><strong>Merge sort 是递归. 值得刷!</strong></li><li><a href="https://www.studytonight.com/data-structures/merge-sort#:~:text=Time%20complexity%20of%20Merge%20Sort,space%20as%20the%20unsorted%20array.">Best Merge Sort guid I found on Internet</a></li></ul><h3 id="Algorithm-2"><a href="#Algorithm-2" class="headerlink" title="Algorithm"></a>Algorithm</h3><ul><li>break the given array in the middle. </li><li>Keep breaking each part until we get each subarray with single element. </li><li>Since each array only have one element, so they are all sorted. Then we merge these arrays back together. It only takes O(n) to merge two sorted arrays. So the divide will take O(logn), which gives us total time complexity of O(nlogn).</li></ul><p>MergeSort(arr[], l,  r)<br>If r &gt; l</p><ol><li>Find the middle point to divide the array into two halves:<br> middle m &#x3D; (l+r)&#x2F;2</li><li>Call mergeSort for first half:<br> Call mergeSort(arr, l, m)</li><li>Call mergeSort for second half:<br> Call mergeSort(arr, m+1, r)</li><li>Merge the two halves sorted in step 2 and 3:<br> Call merge(arr, l, m, r)</li></ol><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSortPractice</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] list = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">93</span>,<span class="number">24</span>,<span class="number">43</span>&#125;;</span><br><span class="line">        mergeSort(list);</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] temp =<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    internalMergeSort(arr, temp, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">internalMergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] temp, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123; </span><br><span class="line">    <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">    <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        internalMergeSort(arr, temp, left, middle);          <span class="comment">//divide left</span></span><br><span class="line">        internalMergeSort(arr, temp, middle+<span class="number">1</span>, right);       <span class="comment">//divide right</span></span><br><span class="line">        mergeSortedArray(arr, temp, left, middle, right);    <span class="comment">//merge</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序子序列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSortedArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> temp[], <span class="type">int</span> left, <span class="type">int</span> middle, <span class="type">int</span> right)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i=left;      </span><br><span class="line">    <span class="type">int</span> j=middle+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Sort and combine into a new temp array. O(n)</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=middle &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;=middle)&#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">        arr[left+i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Space-and-Time-Complexity-3"><a href="#Space-and-Time-Complexity-3" class="headerlink" title="Space and Time Complexity"></a>Space and Time Complexity</h3><ul><li><strong>没有worst case和best case，时间复杂度稳定是O(nlgn)，但是需要开空间</strong></li><li>Time Complexity: <code>O(n*log n)</code></li><li>Space Complexity: <code>O(n)</code></li></ul><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><ul><li>跟 merge sort 一样是divide and conquer</li><li>相较于merge sort直接二分, quick是选一个节点进行比较, 然后把节点放在对的位置, 保证节点前比其小, 后面比节点都大, 之后再进行二分. </li><li>选节点pivot的方法可以自由发挥, 没有固定规定.</li><li>与merge sort的不同在于拼回去的过程之中无需再比较</li></ul><h3 id="Algorithm-3"><a href="#Algorithm-3" class="headerlink" title="Algorithm"></a>Algorithm</h3><ul><li>Select a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, one subarray with elements less than the pivot element, the other with elemnts greater or equal to the pivot element. </li><li>The sub-arrays are then sorted recursively until only one element is left in each subarrays.</li></ul><p>这个图中里选用的是最后一个数作为节点. </p><p><img src="https://www.techiedelight.com/wp-content/uploads/Quicksort.png" alt="Quick Sort Illustration"></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(list, left, right);</span><br><span class="line">        qSort(list, left, pivot-<span class="number">1</span>);</span><br><span class="line">        qSort(list, pivot+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left]; <span class="comment">// 此处选取Left, 也就是第一个数为Pivot. </span></span><br><span class="line">    <span class="comment">// 1. move pivot to end</span></span><br><span class="line">    swap(arr, left, right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">store_index</span> <span class="operator">=</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. move all smaller elements to the left</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">        swap(arr, store_index, i);</span><br><span class="line">        store_index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. move pivot to its final place</span></span><br><span class="line">    swap(arr, store_index, right);</span><br><span class="line">    <span class="keyword">return</span> store_index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Space-and-Time-Complexity-4"><a href="#Space-and-Time-Complexity-4" class="headerlink" title="Space and Time Complexity"></a>Space and Time Complexity</h3><p>For an array, in which partitioning leads to unbalanced subarrays, to an extent where on the left side there are no elements, with all the elements greater than the pivot, hence on the right side.</p><p>And if keep on getting unbalanced subarrays, then <strong>the running time is the worst case, which is <code>O(n^2)</code></strong></p><p>Where as if partitioning leads to almost equal subarrays, then the running time is the best, with time complexity as <code>O(n*log n)</code>.</p><ul><li>Worst Case Time Complexity [ Big-O ]: <code>O(n^2)</code></li><li>Space Complexity: <code>O(1)</code></li></ul><h2 id="Compare-Quick-Sort-and-Merge-Sort"><a href="#Compare-Quick-Sort-and-Merge-Sort" class="headerlink" title="Compare Quick Sort and Merge Sort"></a>Compare Quick Sort and Merge Sort</h2><ul><li>Merge: stable O(nlogn). require O(n) space. </li><li>Quick: not stable. averge O(nlogn), worst scenario O(n^2). O(1) space.</li></ul><h2 id="Quick-Select"><a href="#Quick-Select" class="headerlink" title="Quick Select"></a>Quick Select</h2><p><strong>重点: FB 和 Amazon 最近两年非常喜欢考 LC347 LC973</strong></p><p><img src="https://lh3.googleusercontent.com/pw/AM-JKLWNIJ1Gdr26zSrNm4J3_bG1sqNZukMc4vlIDv-_s-pcZ_fZSz35wHKS6FzwElatBCyHOKjWPUZTwgVRIxBIC5djdTmCMWKgHHfPxlogdRJ9aNDPTNpYh5JMTheshW9pbPbr-_-JNfdQPq0K8mtPXuRy=w1015-h783-no?authuser=0"></p><h3 id="LC215"><a href="#LC215" class="headerlink" title="LC215"></a>LC215</h3><p>另外一种办法, priority Queue, LinkedList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> sort(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(pivot == k)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pivot &lt; k)&#123;</span><br><span class="line">                quickSelect(nums, left + <span class="number">1</span>, right, k);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                quickSelect(nums, left, right - <span class="number">1</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotValue</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        <span class="built_in">this</span>.swap(nums, index, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; pivotValue)&#123;</span><br><span class="line">                <span class="built_in">this</span>.swap(nums, index ++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.swap(nums, index, right);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Count-Sort"><a href="#Count-Sort" class="headerlink" title="Count Sort"></a>Count Sort</h2><p>O(n)</p><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h2><ul><li><a href="https://developerinsider.co/big-o-notation-explained-with-examples/">Guide</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_core_50</title>
      <link href="/2021/11/28/1%20python/0-python-core-50/"/>
      <url>/2021/11/28/1%20python/0-python-core-50/</url>
      
        <content type="html"><![CDATA[<h1 id="python-core-50"><a href="#python-core-50" class="headerlink" title="python-core-50"></a>python-core-50</h1><h2 id="L0-Reminders"><a href="#L0-Reminders" class="headerlink" title="L0 Reminders"></a>L0 Reminders</h2><ul><li><p>输入一个正整数判断是不是素数</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个正整数: &#x27;</span>))</span><br><span class="line">end = <span class="built_in">int</span>(sqrt(num))</span><br><span class="line">is_prime = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, end + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> num % x == <span class="number">0</span>:</span><br><span class="line">        is_prime = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> is_prime <span class="keyword">and</span> num != <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%d是素数&#x27;</span> % num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%d不是素数&#x27;</span> % num)</span><br></pre></td></tr></table></figure></li><li><p>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Todo: Add your code here</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>字典：输入一段话，统计每个英文字母出现的次数</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sentence = <span class="built_in">input</span>(<span class="string">&#x27;请输入一段话: &#x27;</span>)</span><br><span class="line">counter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> sentence:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= ch &lt;= <span class="string">&#x27;Z&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;a&#x27;</span> &lt;= ch &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        counter[ch] = counter.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> counter.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;字母<span class="subst">&#123;key&#125;</span>出现了<span class="subst">&#123;value&#125;</span>次.&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>字典：在一个字典中保存了股票的代码和价格，找出股价大于100元的股票并创建一个新的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stocks = &#123;</span><br><span class="line">    <span class="string">&#x27;AAPL&#x27;</span>: <span class="number">191.88</span>,</span><br><span class="line">    <span class="string">&#x27;GOOG&#x27;</span>: <span class="number">1186.96</span>,</span><br><span class="line">    <span class="string">&#x27;IBM&#x27;</span>: <span class="number">149.24</span></span><br><span class="line">&#125;</span><br><span class="line">stocks2 = &#123;key : value <span class="keyword">for</span> key, value <span class="keyword">in</span> stocks.items() <span class="keyword">if</span> value &gt; <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="L1-basic"><a href="#L1-basic" class="headerlink" title="L1 basic"></a>L1 basic</h2><ul><li><p>缩进</p><ul><li><strong>通常使用4个空格</strong>，强烈建议大家<strong>不要使用制表键来缩进代码</strong></li><li><strong>Flat is better than nested</strong>  少用嵌套</li><li>换行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_leap = year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">      year % <span class="number">400</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注释</p><ul><li>单行注释：以<code>#</code>和空格开头</li><li>多行注释：三个引号 可以折行</li></ul></li><li><p>变量</p><ul><li>命名<ul><li>大小写敏感</li><li>用小写字母拼写，多个单词用下划线连接</li><li>受保护的变量用单个下划线开头</li><li>私有的变量用两个下划线开头</li></ul></li><li>type()<ul><li><code>chr()</code> : 整数 – 字符 </li><li><code>ord()</code> : 字符 – 整数</li></ul></li></ul></li><li><p>运算符</p><ul><li><code>**</code> 指数</li><li><code>//</code> 整除</li><li><code>is</code> <code>is not</code>身份运算符</li><li><code>in</code> <code>not in</code>成员运算符</li><li><code>and</code>  <code>or</code>  <code>not</code> 逻辑运算符</li></ul></li><li><p>输入输出</p><ul><li><p><strong>输入</strong>：</p><ul><li>input 获取字符串，在转化成对应的类型<br> <code>f = float(input(&#39;请输入华氏温度: &#39;))</code></li></ul></li><li><p><strong>输出</strong>: </p><ul><li><code>print</code> 输出多个值（用逗号隔开）  默认以空格分开</li><li>以<code>f</code>打头的字符串中，<code>&#123;变量名&#125;</code>是一个占位符，会被变量对应的值将其替换掉</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c))   <span class="comment"># %.1f是一个占位符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)  <span class="comment"># 冒号后是格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>*<span class="subst">&#123;j&#125;</span>=<span class="subst">&#123;i * j&#125;</span>&#x27;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>pass by value &#x2F; reference</p><ul><li>immutable 不可变对象：pas by value<ul><li>int &#x2F; float &#x2F; bool &#x2F; None</li><li>string</li><li>tuple</li><li>frozensets</li></ul></li><li>可变对象： pass by reference</li></ul></li><li><p>copy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">B = A[:] <span class="comment"># not B = A</span></span><br></pre></td></tr></table></figure></li><li><p>分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">elif</span> x &gt;= -<span class="number">1</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p>循环</p><ul><li><p><strong>for - in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li><code>range</code> : 前开后闭<ul><li><code>range(101)</code>：0-100整数</li><li><code>range(1, 101)</code>：1-100整数</li><li><code>range(1, 101, 2)</code>：1-100的奇数，2是步长</li><li><code>range(100, 0, -2)</code>：100-1的偶数，-2是步长</li></ul></li></ul></li><li><p><strong>while</strong></p></li><li><p>break &amp; continue</p><ul><li>break 只能终止它所在的那个循环</li><li>continue  直接让循环进入下一轮  用来放弃本次循环后续的代码</li></ul></li></ul></li></ul><h2 id="L2-常用数据结构"><a href="#L2-常用数据结构" class="headerlink" title="L2 常用数据结构"></a>L2 常用数据结构</h2><h3 id="列表-可变"><a href="#列表-可变" class="headerlink" title="列表[ ] - 可变"></a>列表[ ] - 可变</h3><ul><li><p>特点： </p><ul><li>一个列表中的元素可以任意的数据类型</li><li>动态扩容</li></ul></li><li><p>创建 </p><ul><li><p>创建列表对象的构造器</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items1 = [<span class="number">35</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">55</span>, <span class="number">87</span>]</span><br><span class="line">items1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">items2 = <span class="built_in">list</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>生成式创建 （<strong>强烈建议</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">items2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;hello world&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27; aeiou&#x27;</span>]</span><br><span class="line">items3 = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&#x27;12&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>嵌套 （矩阵）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scores = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]  </span><br><span class="line">scores[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">95</span></span><br><span class="line"><span class="comment"># [[95, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]</span></span><br><span class="line"></span><br><span class="line">scores = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">5</span>  <span class="comment"># 不要用：浅拷贝，两行仍指向同一内存地址</span></span><br><span class="line">scores[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">95</span> </span><br><span class="line"><span class="comment"># [[95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0]]</span></span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items)):</span><br><span class="line">    <span class="built_in">print</span>(items[index])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li><li><p>运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="built_in">len</span>(items3) <span class="comment"># 长度</span></span><br><span class="line"></span><br><span class="line">items3 = items1 + items2 <span class="comment"># 拼接</span></span><br><span class="line">items4 = [<span class="string">&#x27;hello&#x27;</span>] * <span class="number">3</span> <span class="comment"># 重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">in</span> items3)  <span class="comment"># 成员运算</span></span><br><span class="line">items3[-<span class="number">1</span>] <span class="comment"># 索引 0到N-1 / -1到-N</span></span><br><span class="line"><span class="built_in">print</span>(items3[-<span class="number">5</span>:-<span class="number">7</span>:-<span class="number">1</span>]) <span class="comment"># 切片</span></span><br><span class="line"></span><br><span class="line">items5 == items6 <span class="comment"># 对应索引位置上的元素比较</span></span><br><span class="line">items5 &lt;= items7</span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><p>添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items.append(<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 尾部添加</span></span><br><span class="line">items.insert(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># 指定索引插入</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.remove(<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">items.pop(<span class="number">0</span>) <span class="comment">#删除指位置的元素</span></span><br><span class="line"><span class="keyword">del</span> items[<span class="number">1</span>]</span><br><span class="line">items.clear() <span class="comment"># 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找索引 + 次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(items.index(<span class="string">&#x27;a&#x27;</span>)) <span class="comment"># 返回index</span></span><br><span class="line"><span class="built_in">print</span>(items.index(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>)) <span class="comment">#从索引为3以后的位置查找</span></span><br><span class="line"><span class="built_in">print</span>(items.count(<span class="string">&#x27;a&#x27;</span>)) </span><br></pre></td></tr></table></figure></li><li><p>排序和反转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items.sort()</span><br><span class="line">items.reverse()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="元组-不可变"><a href="#元组-不可变" class="headerlink" title="元组( ) - 不可变"></a>元组( ) - 不可变</h3><ul><li><p>创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">30</span>, <span class="number">10</span>, <span class="number">55</span>)</span><br><span class="line">a = () <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">d = (<span class="string">&#x27;hello&#x27;</span>, ) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">b = (<span class="string">&#x27;hello&#x27;</span>) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>tips: 如果元组中只有一个元素，需要加上一个逗号，否则<code>()</code>就不是代表元组的字面量语法，而是改变运算优先级的圆括号</p></li><li><p>应用场景</p><ul><li><p>打包解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; (1, 10, 100) 打包</span></span><br><span class="line">i, j, k = a <span class="comment"># 解包</span></span><br><span class="line">i, j* = a <span class="comment"># 星号接收多个值 [1, 10, 100] 1000</span></span><br><span class="line">a, *b, c = <span class="string">&#x27;hello&#x27;</span>  <span class="comment"># h [&#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;] o</span></span><br><span class="line">a, b, c = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>] <span class="comment"># a = 1, b = 10, c = 100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法 （不可变）</p><ul><li><strong>拼接</strong>、<strong>成员运算</strong>、<strong>索引和切片</strong></li><li>没有  添加元素、删除元素、清空、排序等</li></ul></li><li><p>和列表是可以相互转换的</p></li></ul><h3 id="字符串-不可变"><a href="#字符串-不可变" class="headerlink" title="字符串 - 不可变"></a>字符串 - 不可变</h3><ul><li><p>转义</p><ul><li><code>r</code>或<code>R</code>开头，原始字符串</li></ul></li><li><p>运算</p><ul><li><code>+</code> 拼接</li><li><code>*</code>重复</li><li><code>in</code>    <code>not in</code></li></ul></li><li><p>比较</p><ul><li><code>&lt; = &gt;</code>  比较对应的编码的大小</li><li><code>s1 is s2</code> 比较内存地址</li></ul></li><li><p>查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;shit&#x27;</span>))      <span class="comment"># 找不到，-1</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&#x27;shit&#x27;</span>))     <span class="comment"># 找不到，ValueError: substring not found</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>))      <span class="comment"># 从索引为5的位置开始查找字符o出现的位置</span></span><br></pre></td></tr></table></figure></li><li><p>修剪 -  <code>strip</code> <code>lstrip</code> <code>rstrip</code>:剪掉左右两端空格之后的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;   jackfrued@126.com  \t\r\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())    <span class="comment"># jackfrued@126.com</span></span><br></pre></td></tr></table></figure></li><li><p>替换 - <code>replace</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;@&#x27;</span>))     <span class="comment"># hell@, w@rld</span></span><br></pre></td></tr></table></figure></li><li><p>拆分 合并 - <code>split</code>  <code>join</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;I love you&#x27;</span></span><br><span class="line">words = s.split() <span class="comment"># 默认空格，[&#x27;I&#x27;, &#x27;love&#x27;, &#x27;you&#x27;]   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>.join(words))  <span class="comment"># I#love#you</span></span><br><span class="line">words = s.split(<span class="string">&#x27;#&#x27;</span>) [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;you&#x27;</span>]   </span><br></pre></td></tr></table></figure></li><li><p>字符串匹配：<code>re</code>模块</p></li></ul><p>###set 集合{ } - 可变</p><ul><li><p>性质</p><ul><li>无序性: 不支持索引</li><li>互异性: 不允许重复</li><li>底层哈希存储 – 性能好<ul><li>元素必须是<code>hashable</code>类型 – 不可变类型 （集合是可变的 不能嵌套）</li></ul></li></ul></li><li><p>创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>()</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment"># h e l o</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125; <span class="comment"># 至少有一个元素，否则是空字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转换成集合(可以去掉列表中的重复元素)</span></span><br><span class="line">set3 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集合的生成式语法(将列表生成式的[]换成&#123;&#125;)</span></span><br><span class="line">set4 = &#123;num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>) <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>运算</p><ul><li><code>in </code>   <code>not in</code></li><li><code>&amp;</code>   <code>|</code>   <code>-</code>  <code>^</code>(对称差 - 除开相交的部分)</li></ul></li><li><p>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line">set1.add(<span class="number">33</span>)</span><br><span class="line">set1.update(&#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>&#125;)</span><br><span class="line"></span><br><span class="line">set1.discard(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> set1:</span><br><span class="line">    set1.remove(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(set1.pop())  <span class="comment"># 随机删除 并 返回</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(set1.isdisjoint(set2))    <span class="comment"># 有没有相同的元素</span></span><br><span class="line">set1.clear()</span><br></pre></td></tr></table></figure></li><li><p>不可变集合 -<code>frozenset</code> hashable (不能添加和删除元素)</p></li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li><p>字典是可变类型，但是 key 必须是不可变类型</p></li><li><p>创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;王大锤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">55</span>&#125;  <span class="comment"># &#123;&#125;</span></span><br><span class="line">person = <span class="built_in">dict</span>(name=<span class="string">&#x27;王大锤&#x27;</span>, age=<span class="number">55</span>)    <span class="comment"># dict 构造器</span></span><br><span class="line">items1 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="string">&#x27;ABCDE&#x27;</span>, <span class="string">&#x27;12345&#x27;</span>))   <span class="comment"># zip压缩两个序列并创建字典 &#123;&#x27;A&#x27;: &#x27;1&#x27;, &#x27;B&#x27;: &#x27;2&#x27;, &#x27;C&#x27;: &#x27;3&#x27;, &#x27;D&#x27;: &#x27;4&#x27;, &#x27;E&#x27;: &#x27;5&#x27;&#125;</span></span><br><span class="line">items3 = &#123;x: x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)&#125;</span><br></pre></td></tr></table></figure></li><li><p>索引 和 遍历</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person:</span><br><span class="line">    person[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">person[<span class="string">&#x27;tel&#x27;</span>] = <span class="string">&#x27;13122334455&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(students.keys())      <span class="comment"># dict_keys([1001, 1002, 1003])</span></span><br><span class="line"><span class="built_in">print</span>(students.values())    <span class="comment"># dict_values([&#123;...&#125;, &#123;...&#125;, &#123;...&#125;])</span></span><br><span class="line"><span class="built_in">print</span>(students.items())     <span class="comment"># dict_items([(1001, &#123;...&#125;), (1002, &#123;....&#125;), (1003, &#123;...&#125;)])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> person:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;person[key]&#125;</span>&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> students.items():</span><br><span class="line">  <span class="built_in">print</span>(key, <span class="string">&#x27;---&gt;&#x27;</span>, value)</span><br></pre></td></tr></table></figure></li><li><p>嵌套的字典 （字典中的键必须是不可变类型）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">students = &#123;</span><br><span class="line">    <span class="number">1001</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;狄仁杰&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">    <span class="number">1002</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;白元芳&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">    <span class="number">1003</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;武则天&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get 没有 返回None或设定的默认值 dict.get(key, default=None) 默认返回值</span></span><br><span class="line"><span class="built_in">print</span>(students.get(<span class="number">1005</span>, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;无名氏&#x27;</span>&#125;))  </span><br><span class="line">    </span><br><span class="line">stu1 = students.pop(<span class="number">1002</span>) <span class="comment"># pop方法通过键删除对应的键值对并返回该值， 没有的话 KeyError</span></span><br><span class="line"><span class="keyword">del</span> student[<span class="string">&#x27;1002&#x27;</span>] <span class="comment"># 没有的话 KeyError</span></span><br><span class="line">key, value = students.popitem() <span class="comment"># 删除字典中最后一组键值对并返回对应的二元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># more： setdefault  update</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="L3-函数"><a href="#L3-函数" class="headerlink" title="L3 函数"></a>L3 函数</h2><ul><li><p>模块管理函数 （不同文件名下有相同函数名）</p><ul><li><p>完全限定名 – 模块名.函数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1 <span class="keyword">as</span> m1</span><br><span class="line">m1.foo()</span><br></pre></td></tr></table></figure></li><li><p>别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo <span class="keyword">as</span> f1</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>作用域</p><ul><li>顺序：“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”<ul><li>局部：函数内</li><li>全局 <code>if __name__ == &#39;__main__&#39;:</code></li><li>内置：内置标识符 eg. <code>print</code></li></ul></li><li>尽量少用全局变量<ul><li>易错</li><li>生命周期长，不能回收内存</li><li>建议技巧：闭包 - 延长局部变量的生命周期</li></ul></li><li>修改<ul><li>修改全局变量  <code>global</code></li><li>修改嵌套变量  <code>nonlocal</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在局部函数中修改 global var</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 200</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>参数（位置参数 命名关键字 关键字参数）</p><ul><li><p>位置参数：默认</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 位置参数（对号入座）</span></span><br><span class="line"><span class="built_in">print</span>(add(c=<span class="number">50</span>, a=<span class="number">100</span>, b=<span class="number">200</span>))    <span class="comment"># 非顺序</span></span><br></pre></td></tr></table></figure></li><li><p><strong>可变参数</strong> <code>*</code>   – 元组（不能处理带参数名的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 可变参数可以放在for循环中取出每个参数的值</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(val) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></li><li><p><strong>命名关键字</strong>：在可变参数<code>*</code>后面的，必须用 参数名 &#x3D; 参数值 传入参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_triangle</span>(<span class="params">*, a, b, c</span>):  <span class="comment"># *前面：位置参数，*后面的：命名关键字参数</span></span><br><span class="line">    <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"><span class="built_in">print</span>(is_triangle(a=<span class="number">3</span>, b=<span class="number">4</span>, c=<span class="number">5</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>关键字参数</strong> <code>**</code> （字典）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(arg) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            result += arg</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> kwargs.values():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(value) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            result += value</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calc(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>))    <span class="comment"># 10</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>高阶函数：函数本身（对象）也可以作为函数的参数 &#x2F; 返回值 </p><ul><li><p>只需要函数名 不要括号 （调用函数才加括号）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*args, init_value, op, **kwargs</span>):</span><br><span class="line">    result = init_value</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(arg) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            result = op(result, arg)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> kwargs.values():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(value) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            result = op(result, value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, init_value=<span class="number">0</span>, op=add, x=<span class="number">4</span>, y=<span class="number">5</span>))      <span class="comment"># 15</span></span><br><span class="line"><span class="built_in">print</span>(calc(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">3</span>, y=<span class="number">4</span>, z=<span class="number">5</span>, init_value=<span class="number">1</span>, op=mul))    <span class="comment"># 120</span></span><br></pre></td></tr></table></figure></li><li><p>内置高阶函数</p><ul><li>filter(function, iterable序列)</li><li>map(function, 序列, …)</li></ul></li></ul></li><li><p>Lambda 函数 （匿名函数：一行代码）</p><ul><li>格式：lambda 参数: 执行表达式</li><li>返回值为表达式结果  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers2 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers1)))</span><br><span class="line"><span class="comment"># 判断素数的函数</span></span><br><span class="line">is_prime = <span class="keyword">lambda</span> x: x &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">all</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> f: x % f, <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(x ** <span class="number">0.5</span>) </span><br><span class="line"><span class="comment"># 传入的序列中所有布尔值都是True，all函数就返回True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>装饰器 (本质：函数)</p><ul><li>参数：被装饰的函数</li><li>返回值：有装饰功能的函数</li><li>语法糖：<code>@装饰器函数</code></li><li><code>functools</code>模块的<code>wraps</code>函数（放在<code>wrapper</code>函数上），可保留被装饰之前的函数，用被装饰函数的<code>__wrapped__</code>属性获得被装饰之前的函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record_time</span>(<span class="params">func</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义一个带装饰功能（记录被装饰函数的执行时间）的函数</span></span><br><span class="line">    <span class="comment"># 因为具体参数，用*args和**kwargs接收所有参数</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>) </span><span class="comment"># 可以取消装饰器（带语法糖的）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs) <span class="comment"># 执行被装饰的函数并获取返回值</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>执行时间: <span class="subst">&#123;end - start:<span class="number">.3</span>f&#125;</span>秒&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 返回被装饰函数的返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper <span class="comment"># # 返回带装饰功能的wrapper函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@record_time </span><span class="comment">#语法糖：download变为装饰器record_time中返回的wrapper函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;开始下载<span class="subst">&#123;filename&#125;</span>.&#x27;</span>)</span><br><span class="line">    time.sleep(random.randint(<span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span>下载完成.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">download = record_time(download) <span class="comment"># 直接调用装饰器</span></span><br><span class="line">download(<span class="string">&#x27;MySQL从删库到跑路.avi&#x27;</span>) <span class="comment"># 利用语法糖</span></span><br><span class="line">download.__wrapped__(<span class="string">&#x27;MySQL必知必会.pdf&#x27;</span>) <span class="comment"># 取消装饰器</span></span><br><span class="line">upload = upload.__wrapped__ <span class="comment"># 取消装饰器</span></span><br><span class="line">upload(<span class="string">&#x27;Python从新手到大师.pdf&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>递归调用</p><ul><li>递归公式</li><li>收敛条件 （结束递归条件）</li><li>通过内存中的栈空间来保存现场和恢复现场，栈空间通常都很小(一般默认1000)，所以递归如果不能迅速收敛，很可能会引发栈溢出错误，从而导致程序的崩溃</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>): <span class="comment"># 收敛条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num * fac(num - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="L18-20-面向对象"><a href="#L18-20-面向对象" class="headerlink" title="L18-20 面向对象"></a>L18-20 面向对象</h2><blockquote><p><strong>面向对象编程</strong>：把一组数据和处理数据的方法组成<strong>对象</strong>，把行为相同的对象归纳为<strong>类</strong>，通过<strong>封装</strong>隐藏对象的内部细节，通过<strong>继承</strong>实现类的特化和泛化，通过<strong>多态</strong>实现基于对象类型的动态分派</p></blockquote><ul><li><p>解决问题： 创建对象 + 向对象发消息</p></li><li><p><strong>三步走</strong></p><ul><li>定义类 （内置类：list set dict）</li><li>创建对象 (内置对象)</li><li>给对象发消息</li></ul></li><li><p>对象 vs 类</p><ul><li>类–抽象 ；  对象–具体<ul><li>属性 – 数据</li><li>方法 – 行为（函数）： 本质上也是属性</li></ul></li><li>对象一定属于某一个类；对象们的相同属性和方法抽象 – 类 （eg. 人类：老师 + 学生）</li><li>类的本质也是对象。一切都是对象：数据 + 函数 + 类 …</li></ul></li><li><p>魔法方法 （<code>__xx__</code>）:以两个下划线开头和结尾，有特殊用途和意义的方法</p></li><li><p>基本</p><ul><li>行为 - 方法（函数）：方法的第一个参数通常都是<code>self</code> – 接收这个消息的对象本身</li><li>属性 - 初始化（把数据放进内存）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:  <span class="comment"># 定义类</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)  <span class="comment"># 不允许动态添加属性   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self, course_name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在学习<span class="subst">&#123;course_name&#125;</span>.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;学生正在玩游戏.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def __repr__(self): # __repr__魔术打印信息，不是地址</span></span><br><span class="line"><span class="string">    return f&#x27;&#123;self.name&#125;: &#123;self.age&#125;&#x27;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">      </span><br><span class="line">stu1 = Student(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">40</span>) <span class="comment"># 用构造器创建Student类下的对象</span></span><br><span class="line"><span class="built_in">print</span>(stu1)    <span class="comment"># &lt;__main__.Student object at 0x10ad5ac50&gt; 内存中的逻辑地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给对象发消息的2种方法</span></span><br><span class="line">Student.study(stu1, <span class="string">&#x27;Python程序设计&#x27;</span>) <span class="comment"># 类.方法（对象 + 参数）</span></span><br><span class="line">stu1.study(<span class="string">&#x27;Python程序设计&#x27;</span>)  <span class="comment"># 对象.方法（参数）</span></span><br><span class="line"></span><br><span class="line">stu.sex = <span class="string">&#x27;男&#x27;</span> <span class="comment"># 动态为对象添加属性</span></span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><p>对象方法</p></li><li><p>静态方法&#x2F;类方法 （类本质也是对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;三角形类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化方法&quot;&quot;&quot;</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># 静态方法参数不用加类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>): </span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod </span><span class="comment"># 类方法 第一个参数为类这个对象本身</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">cls, a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可见性 （很少用）</p><ul><li><p>方法：public</p></li><li><p>属性</p><ul><li><p>私有 private (<code>_name</code>) ：类外无法访问，但可以通过类中方法访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(stu.__name) <span class="comment"># &#x27;Student&#x27; object has no attribute &#x27;__name&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>受保护 protected (<code>__name</code>)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># property装饰器为“私有”属性提供读取和修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 属性访问器(getter方法) - 获取__name属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 属性修改器(setter方法) - 修改__name属性</span></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># self.__name = name if name else &#x27;无名氏&#x27;</span></span><br><span class="line">        self.__name = name <span class="keyword">or</span> <span class="string">&#x27;无名氏&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stu.name, stu.age)    <span class="comment"># 王大锤 20</span></span><br><span class="line">stu.name = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 修改 -- ‘无名氏’</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>支柱：</p><ul><li><p>封装：隐藏实现细节，暴露接口（方法名字 + 参数）</p></li><li><p>继承: 在已有类的基础上创建新类 （父类 –&gt; 子类） （祖先：<code>object</code>）</p><ul><li>继承父类 属性&#x2F;方法</li><li>创建新的 属性&#x2F;方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在吃饭.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, title</span>):</span><br><span class="line">        <span class="comment"># super(Teacher, self).__init__(name, age)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.title = title</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self, course_name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span><span class="subst">&#123;self.title&#125;</span>正在讲授<span class="subst">&#123;course_name&#125;</span>.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">teacher = Teacher(<span class="string">&#x27;武则天&#x27;</span>, <span class="number">35</span>, <span class="string">&#x27;副教授&#x27;</span>)</span><br><span class="line">teacher.eat(<span class="string">&#x27;米饭&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>多态：子类对父类方法改写 – 调用相同的方法，做了不同的事情</p></li></ul></li><li><p>EXAMPLE：</p><blockquote><p><strong>说明</strong>：简单起见，我们的扑克只有52张牌（没有大小王），游戏需要将52张牌发到4个玩家的手上，每个玩家手上有13张牌，按照黑桃、红心、草花、方块的顺序和点数从小到大排列，暂时不实现其他的功能。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum <span class="comment"># m</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suite</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;花色(枚举)&quot;&quot;&quot;</span></span><br><span class="line">    SPADE, HEART, CLUB, DIAMOND = <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, suite, face</span>):</span><br><span class="line">        self.suite = suite</span><br><span class="line">        self.face = face</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        suites = <span class="string">&#x27;♠♥♣♦&#x27;</span></span><br><span class="line">        faces = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]</span><br><span class="line">        <span class="comment"># 根据牌的花色和点数取到对应的字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;suites[self.suite.value]&#125;</span><span class="subst">&#123;faces[self.face]&#125;</span>&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>): <span class="comment"># &lt; 运算符重载</span></span><br><span class="line">        <span class="comment"># 花色相同比较点数的大小</span></span><br><span class="line">        <span class="keyword">if</span> self.suite == other.suite:</span><br><span class="line">            <span class="keyword">return</span> self.face &lt; other.face</span><br><span class="line">        <span class="comment"># 花色不同比较花色对应的值</span></span><br><span class="line">        <span class="keyword">return</span> self.suite.value &lt; other.suite.value</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poker</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;扑克&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 通过列表的生成式语法创建一个装52张牌的列表</span></span><br><span class="line">        self.cards = [Card(suite, face) <span class="keyword">for</span> suite <span class="keyword">in</span> Suite</span><br><span class="line">                      <span class="keyword">for</span> face <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line">        <span class="comment"># current属性表示发牌的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shuffle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;洗牌&quot;&quot;&quot;</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 通过random模块的shuffle函数实现列表的随机乱序</span></span><br><span class="line">        random.shuffle(self.cards)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;发牌&quot;&quot;&quot;</span></span><br><span class="line">        card = self.cards[self.current]</span><br><span class="line">        self.current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_next</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;还有没有牌可以发&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.current &lt; <span class="built_in">len</span>(self.cards)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;玩家&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.cards = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, card</span>):</span><br><span class="line">        self.cards.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrange</span>(<span class="params">self</span>):</span><br><span class="line">        self.cards.sort()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">poker = Poker()</span><br><span class="line">poker.shuffle()</span><br><span class="line">players = [Player(<span class="string">&#x27;东邪&#x27;</span>), Player(<span class="string">&#x27;西毒&#x27;</span>), Player(<span class="string">&#x27;南帝&#x27;</span>), Player(<span class="string">&#x27;北丐&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">        player.get_one(poker.deal())</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">    player.arrange()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;player.name&#125;</span>: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(player.cards)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>要求</strong>：某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算员工的月薪。其中，部门经理的月薪是固定15000元；程序员按工作时间（以小时为单位）支付月薪，每小时200元；销售员的月薪由1800元底薪加上销售额5%的提成两部分构成。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod <span class="comment"># 抽象类：专门勇于继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(metaclass=ABCMeta):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod </span><span class="comment"># 装饰器 抽象方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, working_hour=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.working_hour = working_hour</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span> * self.working_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sales=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.sales = sales</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1800</span> + self.sales * <span class="number">0.05</span></span><br><span class="line">    </span><br><span class="line">emps = [</span><br><span class="line">    Manager(<span class="string">&#x27;刘备&#x27;</span>), Programmer(<span class="string">&#x27;诸葛亮&#x27;</span>), Manager(<span class="string">&#x27;曹操&#x27;</span>), </span><br><span class="line">    Programmer(<span class="string">&#x27;荀彧&#x27;</span>), Salesman(<span class="string">&#x27;吕布&#x27;</span>), Programmer(<span class="string">&#x27;张辽&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(emp, Programmer): <span class="comment"># 判断对象的类的匹配</span></span><br><span class="line">        emp.working_hour = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&#x27;请输入<span class="subst">&#123;emp.name&#125;</span>本月工作时间: &#x27;</span>))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(emp, Salesman):</span><br><span class="line">        emp.sales = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">f&#x27;请输入<span class="subst">&#123;emp.name&#125;</span>本月销售额: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;emp.name&#125;</span>本月工资为: ￥<span class="subst">&#123;emp.get_salary():<span class="number">.2</span>f&#125;</span>元&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decision_Tree</title>
      <link href="/2021/08/26/1%20python/Decision-Tree/"/>
      <url>/2021/08/26/1%20python/Decision-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树概述"><a href="#决策树概述" class="headerlink" title="决策树概述"></a>决策树概述</h1><ul><li><p>算法核心： </p><ul><li>如何从数据表中找出最佳节点和最佳分枝？</li><li>如何让决策树停止生长，防止过拟合？</li></ul><span id="more"></span></li><li><p>sklearn中的决策树 （模块sklearn.tree）</p><table><thead><tr><th>tree.DecisionTreeClassifier</th><th>分类树</th></tr></thead><tbody><tr><td>tree.DecisionTreeRegressor</td><td>回归树</td></tr><tr><td>tree.export_graphviz</td><td>将生成的决策树导出为DOT格式，画图专用</td></tr><tr><td>tree.ExtraTreeClassifier</td><td>高随机版本的分类树</td></tr><tr><td>tree.ExtraTreeRegressor</td><td>高随机版本的回归树</td></tr></tbody></table></li><li><p>sklearn的基本建模流程</p><ul><li>导入模块</li><li>实例化 - 建立模型 </li><li>训练模型 model &#x3D; model.fit(X_train, Y_train)</li><li>通过模型接口获得信息 (score, apply, predict…)</li></ul></li></ul><h1 id="DecisionTreeClassifier与红酒数据集"><a href="#DecisionTreeClassifier与红酒数据集" class="headerlink" title="DecisionTreeClassifier与红酒数据集"></a>DecisionTreeClassifier与红酒数据集</h1><ul><li>决策树的基本流程<ul><li>计算全部特征的不纯度</li><li>选取最优不纯度来分支</li><li>计算条件不纯度，选取最优不纯度来分支。重复直到整体不纯度最优或无多余特征</li></ul></li></ul><p>class <code>sklearn.tree.DecisionTreeClassifier</code> </p><p>(<strong>criterion</strong>&#x3D;’gini’, <strong>splitter</strong>&#x3D;’best’, <strong>max_depth</strong>&#x3D;None, <strong>min_samples_split</strong>&#x3D;2, <strong>min_samples_leaf</strong>&#x3D;1, <strong>min_weight_fraction_leaf</strong>&#x3D;0.0, <strong>max_features</strong>&#x3D;None, <strong>random_state</strong>&#x3D;None, max_leaf_nodes&#x3D;None, <strong>min_impurity_decrease</strong>&#x3D;0.0, <strong>min_impurity_split</strong>&#x3D;None, <strong>class_weight</strong>&#x3D;None, <strong>presort</strong>&#x3D;False)</p><ul><li>确认最优的剪枝参数 –&gt; 超参数的曲线</li><li>八个参数：<ul><li>Criterion</li><li>两个随机性相关的参数（random_state，splitter）</li><li>五个剪枝参数（max_depth, min_samples_split，min_samples_leaf，max_feature，min_impurity_decrease）</li></ul></li><li>一个属性：feature_importances_</li><li>四个接口：fit，score，apply，predict</li></ul><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><h3 id="criterion-（“entropy”-“gini”）"><a href="#criterion-（“entropy”-“gini”）" class="headerlink" title="criterion （“entropy” “gini”）"></a>criterion （“entropy” “gini”）</h3><ul><li><p>作用：决定不纯度的计算方法 </p><ul><li>不纯度越低，决策树对训练集的拟合越好</li><li>子节点的不纯度一定是低于父节点</li></ul></li><li><p>选择：（“entropy” “gini”）（default - gini）</p><ul><li>信息熵（Entropy）: 实际计算的是基于信息熵的信息增益(Information Gain) –&gt; 父子差</li><li>基尼系数（Gini Impurity）</li></ul><p>区别：欠拟合使用信息熵，过拟合使用基尼系数</p><ul><li>信息熵对不纯度更加敏感，对不纯度的惩罚最强。决策树的生长会更加“精细”。对于高维数据或者噪音很多的数据，信息熵很容易过拟合。</li><li>信息熵的计算比基尼系数缓慢一些，因为基尼系数的计算不涉及对数。</li></ul></li></ul><h3 id="random-state"><a href="#random-state" class="headerlink" title="random_state"></a>random_state</h3><ul><li>作用：设置分枝中的随机模式的参数。默认None</li></ul><h3 id="splitter-“random”-“best”"><a href="#splitter-“random”-“best”" class="headerlink" title="splitter(“random” “best”)"></a>splitter(“random” “best”)</h3><ul><li><p>作用：控制决策树中的随机选项</p></li><li><p>选择：(“random” “best”)</p><ul><li>best: 优先选择更重要的特征进行分枝 feature_importances_</li><li>random: 更随机，树会因为含有更多的不必要信息而更深更大，并因这些不必要信息而降低对训练集的拟合 –&gt; 防止过拟合 (树一旦建成，我们依然是使用剪枝参数来防止过拟合)</li></ul></li></ul><h3 id="max-depth"><a href="#max-depth" class="headerlink" title="max_depth"></a>max_depth</h3><ul><li>限制树的最大深度，超过设定深度的树枝全部剪掉</li><li>在高维度低样本量时非常有效。决策树多生长一层，对样本量的需求会增加一倍，所 以限制树深度能够有效地限制过拟合</li><li>建议从&#x3D;3开始尝试，看看拟合的效 果再决定是否增加设定深度</li></ul><h3 id="min-samples-leaf"><a href="#min-samples-leaf" class="headerlink" title="min_samples_leaf"></a>min_samples_leaf</h3><ul><li>一个节点在分枝后的每个<strong>子节点</strong>都必须包含至少min_samples_leaf个训练样本，否则分 枝就不会发生，或者，分枝会朝着满足每个子节点都包含min_samples_leaf个样本的方向去发生</li><li>这个参数的数量设置得太小会引 起过拟合，设置得太大就会阻止模型学习数据</li><li>建议从&#x3D;5开始使用。如果叶节点中含有的样本量变化很大，建议输入浮点数作为样本量的百分比来使用</li></ul><h3 id="min-samples-split"><a href="#min-samples-split" class="headerlink" title="min_samples_split"></a>min_samples_split</h3><ul><li>一个<strong>节点</strong>必须要包含至少min_samples_split个训练样本，这个节点才允许被分枝。即中间节点包含样本数必须大于min_samples_split</li></ul><h3 id="max-features"><a href="#max-features" class="headerlink" title="max_features"></a>max_features</h3><ul><li>限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃</li><li>过于暴力，一般不推荐是使用（优先考虑PCA, ICA…）</li></ul><h3 id="min-impurity-decrease"><a href="#min-impurity-decrease" class="headerlink" title="min_impurity_decrease"></a>min_impurity_decrease</h3><ul><li>限制信息增益的大小，信息增益小于设定数值的分枝不会发生。其目的在于删去贡献小的分支。</li></ul><h3 id="class-weight-min-weight-fraction-leaf"><a href="#class-weight-min-weight-fraction-leaf" class="headerlink" title="class_weight &amp; min_weight_fraction_leaf"></a>class_weight &amp; min_weight_fraction_leaf</h3><ul><li>样本不平衡的时候使用</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><h3 id="探索数据"><a href="#探索数据" class="headerlink" title="探索数据"></a>探索数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">wine = load_wine()</span><br><span class="line">wine.data.shape</span><br><span class="line">wine.target</span><br><span class="line"></span><br><span class="line">pd.concat([pd.DataFrame(wine.data), pd.DataFrame(wine.target)],</span><br><span class="line">          axis=<span class="number">1</span>)  <span class="comment"># axis = 0 (row) / 1(column)</span></span><br><span class="line"></span><br><span class="line">wine.feature_names</span><br><span class="line">wine.target_names</span><br></pre></td></tr></table></figure><pre><code>array([&#39;class_0&#39;, &#39;class_1&#39;, &#39;class_2&#39;], dtype=&#39;&lt;U7&#39;)</code></pre><h3 id="训练集和测试集-train-test-split"><a href="#训练集和测试集-train-test-split" class="headerlink" title="训练集和测试集 train_test_split"></a>训练集和测试集 train_test_split</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Xtrain, Xtest, Ytrain, Ytest = train_test_split(</span><br><span class="line">    wine.data, wine.target, test_size=<span class="number">0.3</span>)  <span class="comment"># 7:3</span></span><br><span class="line">Xtrain.shape</span><br><span class="line">Xtest.shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">54</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure><h3 id="建立模型-剪枝-确定超参数"><a href="#建立模型-剪枝-确定超参数" class="headerlink" title="建立模型 剪枝&#x2F;确定超参数"></a>建立模型 剪枝&#x2F;确定超参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = tree.DecisionTreeClassifier(criterion = <span class="string">&quot;entropy&quot;</span>, random_state = <span class="number">30</span>, splitter = <span class="string">&quot;best&quot;</span>, max_depth = <span class="number">3</span></span><br><span class="line">                                   <span class="comment"># , min_samples_leaf=5, min_samples_split= 5</span></span><br><span class="line">                                   )</span><br><span class="line">model = model.fit(Xtrain, Ytrain)</span><br><span class="line">score = model.score(Xtest,Ytest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(model.score(Xtrain,Ytrain))</span><br><span class="line">score</span><br></pre></td></tr></table></figure><pre><code>0.98387096774193550.9074074074074074</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">test = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  <span class="comment"># 0-9</span></span><br><span class="line">    model = tree.DecisionTreeClassifier(max_depth=i+<span class="number">1</span>, criterion=<span class="string">&quot;entropy&quot;</span>, random_state=<span class="number">30</span>, splitter=<span class="string">&quot;best&quot;</span></span><br><span class="line">                                        )</span><br><span class="line">    model = model.fit(Xtrain, Ytrain)</span><br><span class="line">    score = model.score(Xtest, Ytest)</span><br><span class="line">    test.append(score)</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>), test, color=<span class="string">&quot;red&quot;</span>,</span><br><span class="line">         label=<span class="string">&quot;max_depth&quot;</span>)  <span class="comment"># range(1,11):1-10</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​    ![output_7_0](C:\Users\Ashley Li\Desktop\Ashley37sky.github.io\source_posts\image\output_7_0.png)</p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">feature_names = wine.feature_names</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">dot_data = tree.export_graphviz(model  <span class="comment"># 逗号写在前面方便注释</span></span><br><span class="line">                               , out_file = <span class="literal">None</span></span><br><span class="line">                               , feature_names = feature_names</span><br><span class="line">                               , class_names= [<span class="string">&quot;可乐&quot;</span>,<span class="string">&quot;雪碧&quot;</span>,<span class="string">&quot;橙汁&quot;</span>]</span><br><span class="line">                               , filled = <span class="literal">True</span> <span class="comment"># 填充颜色（颜色：类别，深浅：不纯度）</span></span><br><span class="line">                                , rounded = <span class="literal">True</span> <span class="comment"># 椭圆边框</span></span><br><span class="line">                               )</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph</span><br></pre></td></tr></table></figure><p>​    </p><p>![output_9_0](C:\Users\Ashley Li\Desktop\Ashley37sky.github.io\source_posts\image\output_9_0.svg)</p><h3 id="探索决策树"><a href="#探索决策树" class="headerlink" title="探索决策树"></a>探索决策树</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.feature_importances_</span><br><span class="line">[*<span class="built_in">zip</span>(feature_names, model.feature_importances_)]</span><br></pre></td></tr></table></figure><pre><code>[(&#39;alcohol&#39;, 0.0), (&#39;malic_acid&#39;, 0.0), (&#39;ash&#39;, 0.0), (&#39;alcalinity_of_ash&#39;, 0.0), (&#39;magnesium&#39;, 0.059412770833065044), (&#39;total_phenols&#39;, 0.11768999894990434), (&#39;flavanoids&#39;, 0.03239612249873199), (&#39;nonflavanoid_phenols&#39;, 0.0), (&#39;proanthocyanins&#39;, 0.03491820348040222), (&#39;color_intensity&#39;, 0.01848749117382521), (&#39;hue&#39;, 0.05517932728388334), (&#39;od280/od315_of_diluted_wines&#39;, 0.2425246325705508), (&#39;proline&#39;, 0.439391453209637)]</code></pre><h3 id="测试样本"><a href="#测试样本" class="headerlink" title="测试样本"></a>测试样本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.apply(Xtest) <span class="comment"># 返回测试样本所在的叶子节点</span></span><br><span class="line">model.predict(Xtest)</span><br></pre></td></tr></table></figure><pre><code>array([1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 2, 1, 0, 2, 1, 2, 0, 0, 2, 0, 0, 1,       1, 2, 1, 0, 0, 1, 0, 1, 1, 2, 2, 0, 1, 2, 2, 2, 0, 1, 1, 2, 1, 2,       0, 0, 1, 0, 1, 1, 1, 1, 0, 2])</code></pre>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter notebook</title>
      <link href="/2021/08/25/1%20python/1_3_jupter_notebook/"/>
      <url>/2021/08/25/1%20python/1_3_jupter_notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li><code>h</code> 查看所有快捷键</li></ul><span id="more"></span><ul><li><ul><li><code>Enter</code> 从命令模式进入编辑模式</li><li><code>Esc</code>    从编辑模式退回到命令模式</li></ul></li><li><ul><li><code>m</code> 将代码单元格转换为Markdown单元格</li><li><code>y</code> 将Markdown单元格转换为代码单元格</li></ul></li><li><ul><li><code>shift+Enter</code> 运行本单元格，选择下面的代码块</li><li><code>ctrl+Enter</code> 运行本单元格</li><li><code>alt+Enter</code> 运行本单元格，在下方新建一个单元格</li></ul></li><li><ul><li><code>a</code> 在上方新建一个单元格（above）</li><li><code>b</code> 在下方新建一个单元格（below）</li></ul></li><li><ul><li><code>d</code> 删除选中的单元格（delete）</li><li><code>z</code> 恢复</li><li><code>x</code> 剪切本单元格</li><li><code>c</code> 复制本单元格<ul><li><code>shift v</code> 粘贴到上面</li><li><code>v</code> 粘贴到下面</li></ul></li></ul></li><li><code>l</code> 显示代码行号</li></ul>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2021/03/01/Linux/1_2_Linux_command/"/>
      <url>/2021/03/01/Linux/1_2_Linux_command/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>**cmd [-options] [arguments] **</p><ul><li>Linux<strong>区分大小</strong></li><li>个别命令不遵循此格式</li><li>有多个选项时，可以写在一起   eg ls -la &#x2F;etc</li></ul><span id="more"></span><ul><li><strong>简化选项</strong>前使用<strong>一个</strong><code>减号-</code>。<strong>完整选项</strong>前使用两个<code>减号--</code>   eg. -a &#x3D;&#x3D; –all</li><li><strong>通配符</strong><ul><li>*：匹配任何字符和任何数目的字符</li><li>?：匹配单一数目的任何字符</li><li>[ ]：匹配[ ]之内的任意一个字符</li><li>[! ]：匹配除了[! ]之外的任意一个字符，!表示非的意思</li></ul></li></ul><h2 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h2><ul><li><code>pwd</code>（print working directory）：查看用户的当前目录</li><li><code>cd</code> ： 切换目录</li><li><code>.</code>表示当前目录</li><li><code>..</code> 表示当前目录的上一级目录（父目录）</li><li><code>-</code>表示用 cd 命令切换目录<strong>前</strong>所在的目录</li><li><code>~</code> 表示<strong>用户主目录</strong>的绝对路径名</li><li><code>clear</code>:清屏</li></ul><!--more--><ul><li><strong>绝对路径：</strong>以斜线（&#x2F;）开头 </li><li><strong>相对路径 ：</strong>不以斜线（&#x2F;）开头</li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>ctrl+l</code> clear screen</li><li><code>ctrl+r</code>  查看历史命令</li><li><code>ctrl+q</code> quit</li></ul><h2 id="文件-目录处理命令"><a href="#文件-目录处理命令" class="headerlink" title="文件&#x2F;目录处理命令"></a>文件&#x2F;目录处理命令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul><li><p>-a (all)： 显示隐藏文件</p></li><li><p>-d (directory) 显示目录本身</p></li><li><p>-h (human) 显示单位</p></li><li><p>-i (id)：i节点，理解为身份证</p></li><li><p>-l (long): 显示属性</p><p><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210301200427123.png" alt="image-20210301200427123"></p><ol><li>u-user 所有者（一个用户）</li><li>g-group 所属组（一个组）</li><li>o-other 其他人</li></ol><p>eg.</p><table><thead><tr><th>-</th><th>-二进制文件       d目录         l软连接文件</th></tr></thead><tbody><tr><td>rw-</td><td>u</td></tr><tr><td>r–</td><td>g</td></tr><tr><td>r–</td><td>o</td></tr></tbody></table><ul><li>r：读  </li><li>w：写</li><li>x：执行</li></ul></li></ul><h3 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h3><ul><li><code>mkdir</code>: 创建新目录<ul><li>-p 递归创建</li><li>可同时创建多个目录，空格隔开</li></ul></li></ul><ul><li><code>rmdir</code>：删除空目录 （很很少用）</li><li><code>cp [origin] [new]</code>：复制文件<ul><li>-r：复制目录</li><li>-p：保留文件属性 （eg.修改时间）</li><li>复制的时候可以改名<ul><li>cp -r &#x2F;tmp&#x2F;test &#x2F;root&#x2F;test1</li><li>cp -r &#x2F;rmp&#x2F;test &#x2F;root (不改名)</li></ul></li></ul></li><li><code>mv [origin] [new]</code>：移动文件或目录、改名(同一目录下移动并改成新名字)</li><li><code>rm</code>：删除文件<ul><li>-r 删除目录</li><li>-f 强制删除（不会询问是否删除）</li><li>常用 rm -rf</li></ul></li></ul><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><ul><li><code>touch [文件名]</code>： 创建空文件、</li><li><code>cat</code>: 显示文件内容<ul><li>-n: 显示行号</li></ul></li><li><code>tac</code>：反向显示文件内容</li><li><code>more</code>:分页显示文件内容<ul><li>空格、f  –&gt; 翻页</li><li>enter  –&gt;换行</li><li>q、Q  –&gt;退出</li></ul></li><li><code>less</code>: more升级版<ul><li>pgup：向上翻页</li><li>&#x2F;[keyword]: 搜索<ul><li>n：下一个关键词所在位置</li></ul></li></ul></li><li><code>head</code>：显示文件前几行<ul><li>-n 指定行数，默认10</li></ul></li><li><code>tail</code>：显示文件后几行<ul><li>-n </li><li>-f：动态显示，实时更新（日志）</li></ul></li><li><code>find</code>：查找文件</li></ul><h3 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h3><ul><li><p><code>ln [原文件] [目标文件]</code>：建立链接文件</p><ul><li>-s：创建软连接</li></ul><table><thead><tr><th align="center">软链接（同win快捷方式，常用）</th><th>硬链接（很少用）</th></tr></thead><tbody><tr><td align="center">显示lrwxrwxrwx，实际文件操作权限才有决定权</td><td>除文件名都一样</td></tr><tr><td align="center">很小，只是符号链接，有箭头指向</td><td>i节点同源文件，两文件同时更新</td></tr><tr><td align="center">可以是目录</td><td>不能是目录</td></tr><tr><td align="center">删除原文件后不能访问软链接</td><td>删除原文件后能访问硬链接</td></tr><tr><td align="center">可以跨分区</td><td>不能跨分区 (&#x2F;boot  &#x2F;home   &#x2F;)</td></tr></tbody></table></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>echo</code>：把内容重定向到指定的文件中 ，有则打开，无则创建</li><li><code>管道命令 |</code> ：将前面的结果给后面的命令，例如：<code>ls -la | wc</code>，将ls的结果加给wc命令来统计字数</li></ul><ul><li><code>重定向 &gt; 是覆盖模式，&gt;&gt; 是追加模式</code>，例如：<code>echo &quot;Java3y,zhen de hen xihuan ni&quot; &gt; qingshu.txt</code>把左边的输出放到右边的文件里去</li></ul><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><h3 id="更改权限-chmod"><a href="#更改权限-chmod" class="headerlink" title="更改权限-chmod"></a>更改权限-chmod</h3><p>chmod：（change mode）root、所有者可以执行</p><p>两种方式</p><ul><li><p><code>chmod [&#123;ugoa&#125; &#123;+-=&#125; &#123;rwx&#125; [文件或目录]]</code></p></li><li><p><code>chmod [421] [文件或目录]</code> (更常用)</p><p>ps. r—4, w–2, x–1</p><p>​  rwxrw-r–(764)</p><ul><li><code>-R</code> 递归修改 （把目录及其子目录全西安都修改）</li><li>一次更改多个权限，用逗号隔开 <code>g+w,o-r</code></li></ul></li></ul><p> 补充： 创建普通用户，组</p><ul><li><code>useradd __</code>          <code>passwd  __</code></li><li><code>groupadd</code></li></ul><p><strong>重要：file和directory的rwx权限</strong></p><table><thead><tr><th></th><th>file</th><th>directory</th></tr></thead><tbody><tr><td>r</td><td>cat&#x2F;more&#x2F;head&#x2F;tail&#x2F;less</td><td>ls （列出目录内容）</td></tr><tr><td>w</td><td>vim （可修改文件）</td><td>touch&#x2F;mkdir&#x2F;rmdir&#x2F;rm （可在目录中创建删除文件）</td></tr><tr><td>x</td><td>script command</td><td>cd （可以进入目录，所以一般rx同时出现）</td></tr></tbody></table><ul><li>文件 w权限 &#x3D; 修改文件</li><li>目录 w权限 &#x3D; 删除创建文件</li><li>对文件有权限，但是进不去文件所在目录也不行</li></ul><h3 id="其他权限命令"><a href="#其他权限命令" class="headerlink" title="其他权限命令"></a>其他权限命令</h3><ul><li><p><code>chown [用户] [文件或目录]</code>: change ownership 改变所有者，只有root能执行</p></li><li><p><code>umask</code>  显示，设置文件的缺省（默认）权限</p><ul><li><code>-S</code> : 以rwx显示新建文件的default权限</li><li>不加S</li></ul><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210311143914415.png" alt="image-20210311143914415" style="zoom: 25%;" /></li></ul><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find [搜索范围] [匹配条件]</code></p><ul><li><p><code>find [搜索范围] -name [条件]</code></p><ul><li><code>-iname</code></li><li><code>*</code> 匹配多个  <code>?</code> 匹配一个字符</li></ul></li><li><p><code>find [搜索范围] -size +204800</code> 查找大于100MB的文件</p><ul><li><p><code>+ - =</code></p></li><li><p>size 是数据块大小  1个数据块-512字节-0.5k</p><p>（100M &#x3D; 102400K &#x3D;204800数据块）</p></li></ul></li><li><p><code>find [搜索范围] -user [用户名]</code>  查找以用户名为所属者的文件</p><ul><li><code>-group</code>    根据所属组查找</li></ul></li><li><p><code>find [搜索范围] -cmin -5</code>  查找5min内被修改过属性的文件和目录</p><ul><li><code>amin</code>   access 访问时间</li><li><code>cmin</code> change 文件属性</li><li><code>mmin</code> modify 文件内容</li></ul></li><li><p><code>-type</code> 根据文件类型查找</p><ul><li>f：文件</li><li>d：目录</li><li>l：软连接文件</li></ul></li><li><p>多个条件</p><ul><li><p><code>-a</code> and</p><p>eg. <code>find /etc -size +163940 -a size -204800</code></p></li><li><p><code>-o</code> or</p></li></ul></li><li><p><code>-exec/-ok [命令] &#123;&#125; \</code> 对搜索结果执行操作</p><ul><li>eg. <code>find /etc -name init -exec ls -l &#123;&#125; \</code></li><li><code>-ok</code> 会询问是否确定操作</li></ul></li></ul><h3 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h3><ul><li><code>locat [文件]</code>再文件资料库中查找文件<ul><li><code>-i</code> 不区分大小写</li><li><code>updatedb</code> 更新资料库</li><li>查找比find快，但是新建文件后 如果资料库未更新 则搜不到文件</li><li>&#x2F;tmp 的文件搜不到</li></ul></li><li><code>which [命令]</code> 搜索 命令 所在 目录 和 别名</li><li><code>whereis [命令]</code> 搜索 命令 所在 目录 和 帮助文档路径</li><li><code>grep -iv [指定字串] [文件]</code> 在文件中搜寻字串匹配的行并输出<ul><li><code>-i</code> 不区分大小写</li><li><code>-v</code> 排除指定字符串</li><li><code>grep -v ^# [file]</code> 去掉以#开头的行（注释行）</li></ul></li></ul><h2 id="压缩-解压"><a href="#压缩-解压" class="headerlink" title="压缩&#x2F;解压"></a>压缩&#x2F;解压</h2><ul><li><p><code>gzip filename</code></p></li><li><p><code>bzip2 filename</code></p></li><li><p><code>tar -czvf filename</code></p></li><li><p><code>gzip -d filename.gz</code></p></li><li><p><code>bzip2 -d filename.bz2</code></p></li><li><p><code>tar -xzvf filename.tar.gz</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kaggle</title>
      <link href="/2021/02/02/1%20python/1_kaggle-intro%20to%20ML/"/>
      <url>/2021/02/02/1%20python/1_kaggle-intro%20to%20ML/</url>
      
        <content type="html"><![CDATA[<h1 id="kaggle-intro-to-ML"><a href="#kaggle-intro-to-ML" class="headerlink" title="kaggle-intro to ML"></a>kaggle-intro to ML</h1><h2 id="pandas-data"><a href="#pandas-data" class="headerlink" title="pandas - data"></a>pandas - data</h2><ul><li><p>read data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data_file_path = <span class="string">&#x27;../../../data.csv&#x27;</span></span><br><span class="line">data = pd.read_csv(data_file_path)</span><br></pre></td></tr></table></figure><span id="more"></span></li><li><p>DataFrame –&gt; sheet in Excel</p></li><li><p>see data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.shape()  <span class="comment"># (row, column)</span></span><br><span class="line">data.describe()    <span class="comment"># count / mean / std / max / min ...</span></span><br><span class="line">data.head()    <span class="comment"># top 5 rows</span></span><br><span class="line">data.columns   <span class="comment"># columns names</span></span><br></pre></td></tr></table></figure></li><li><p>select data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data.columns   <span class="comment"># columns names</span></span><br><span class="line">data = data.dropna(axis=<span class="number">0</span>) <span class="comment"># drop not available (missing) data</span></span><br><span class="line"></span><br><span class="line">y = data.price <span class="comment"># select prediction target</span></span><br><span class="line"></span><br><span class="line">data_features = [<span class="string">&#x27;rooms&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;direction&#x27;</span>]  </span><br><span class="line">X = data[data_features]</span><br><span class="line">X.describe()  <span class="comment"># check</span></span><br><span class="line">X.head()</span><br></pre></td></tr></table></figure><ul><li><p>select prediction target</p><ul><li>select column –&gt; dot notation</li><li>single column is stored in <code>Series</code></li></ul></li><li><p>select features</p><ul><li>a list of column names –&gt; string with quotes</li></ul></li></ul></li></ul><h2 id="Sklearn-scikit-learn-Model"><a href="#Sklearn-scikit-learn-Model" class="headerlink" title="Sklearn (scikit-learn) - Model"></a>Sklearn (scikit-learn) - Model</h2><ul><li><p>modeling the types of data typically stored in DataFrames</p></li><li><p>steps</p><ul><li>define (model + parameters)</li><li>fit</li><li>predict</li><li>evaluate</li></ul></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"></span><br><span class="line">train_X, val_X, train_y, val_y = train_test_split(X, y, random_state = <span class="number">0</span>) <span class="comment"># split test to train and validation</span></span><br><span class="line">house_model = DecisionTreeRegressor () <span class="comment"># define</span></span><br><span class="line">house_model.fit(train_X, train_y) <span class="comment"># fit</span></span><br><span class="line">val_prediciton = house_model.predict(val_X) <span class="comment"># predict</span></span><br><span class="line">error = mean_absolute_error(val_y, val_prediciton) <span class="comment">#evaluate</span></span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure><ul><li><code>random_state</code> ensures you get the same results in each run, can use any number</li></ul></li><li><p>overfitting vs. underfitting by <code>max_leaf_nodes</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">melbourne_file_path = <span class="string">&#x27;../input/melbourne-housing-snapshot/melb_data.csv&#x27;</span></span><br><span class="line">melbourne_data = pd.read_csv(melbourne_file_path) </span><br><span class="line"><span class="comment"># Filter rows with missing values</span></span><br><span class="line">filtered_melbourne_data = melbourne_data.dropna(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Choose target and features</span></span><br><span class="line">y = filtered_melbourne_data.Price</span><br><span class="line">melbourne_features = [<span class="string">&#x27;Rooms&#x27;</span>, <span class="string">&#x27;Bathroom&#x27;</span>, <span class="string">&#x27;Landsize&#x27;</span>, <span class="string">&#x27;BuildingArea&#x27;</span>]</span><br><span class="line">X = filtered_melbourne_data[melbourne_features]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_mae</span>(<span class="params">max_leaf_nodes, train_X, val_X, train_y, val_y</span>):</span><br><span class="line">    model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=<span class="number">0</span>)</span><br><span class="line">    model.fit(train_X, train_y)</span><br><span class="line">    preds_val = model.predict(val_X)</span><br><span class="line">    mae = mean_absolute_error(val_y, preds_val)</span><br><span class="line">    <span class="keyword">return</span>(mae)</span><br><span class="line"></span><br><span class="line"><span class="comment"># split data into training and validation data, for both features and target</span></span><br><span class="line">train_X, val_X, train_y, val_y = train_test_split(X, y,random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare MAE with differing values of max_leaf_nodes</span></span><br><span class="line"><span class="keyword">for</span> max_leaf_nodes <span class="keyword">in</span> [<span class="number">5</span>, <span class="number">50</span>, <span class="number">500</span>, <span class="number">5000</span>]:</span><br><span class="line">    scores = &#123;leaf_size: get_mae(leaf_size, train_X, val_X, train_y, val_y) <span class="keyword">for</span> leaf_size <span class="keyword">in</span> candidate_max_leaf_nodes&#125;</span><br><span class="line">    </span><br><span class="line">best_tree_size = <span class="built_in">min</span>(scores, key=scores.get)</span><br><span class="line"></span><br><span class="line">final_model = DecisionTreeRegressor(max_leaf_nodes = best_tree_size, random_state = <span class="number">0</span>)</span><br><span class="line">final_model.fit(X, y)</span><br><span class="line"></span><br><span class="line">test_data_path = <span class="string">&#x27;../input/test.csv&#x27;</span></span><br><span class="line">test_data = read_csv(test_data_path)</span><br><span class="line">test_X = test_data[features]</span><br><span class="line">test_preds = rf_model.predict(test_X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># save predictions in format used for competition scoring</span></span><br><span class="line">output = pd.DataFrame(&#123;<span class="string">&#x27;Id&#x27;</span>: test_data.Id,</span><br><span class="line">                       <span class="string">&#x27;SalePrice&#x27;</span>: test_preds&#125;)</span><br><span class="line">output.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get(self, key, default=<span class="literal">None</span>, /)</span><br><span class="line">    Return the value <span class="keyword">for</span> key <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">in</span> the dictionary, <span class="keyword">else</span> default</span><br></pre></td></tr></table></figure></li><li><p>random forest –&gt; many random trees and take average</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"></span><br><span class="line">forest_model = RandomForestRegressor(random_state=<span class="number">1</span>)</span><br><span class="line">forest_model.fit(train_X, train_y)</span><br><span class="line">melb_preds = forest_model.predict(val_X)</span><br><span class="line"><span class="built_in">print</span>(mean_absolute_error(val_y, melb_preds))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/2020/11/19/1%20python/1_python-basic/"/>
      <url>/2020/11/19/1%20python/1_python-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="from-kaggle"><a href="#from-kaggle" class="headerlink" title="from kaggle"></a>from kaggle</h2><ul><li><p>help()   : pass the name, not the result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">round</span>)</span><br><span class="line"><span class="comment"># help(round(3.0))</span></span><br></pre></td></tr></table></figure></li><li><p>docstring：provide a description of a function</p><span id="more"></span><ul><li>triple-quoted string</li><li>after the header of a function</li><li>help() –&gt; shows the docstring</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">least_difference</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the smallest difference between any two numbers</span></span><br><span class="line"><span class="string">    among a, b and c.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; least_difference(1, 5, -5)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    diff1 = <span class="built_in">abs</span>(a - b)</span><br><span class="line">    diff2 = <span class="built_in">abs</span>(b - c)</span><br><span class="line">    diff3 = <span class="built_in">abs</span>(a - c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(diff1, diff2, diff3)</span><br></pre></td></tr></table></figure></li><li><p>and 优先级 &gt; or</p></li><li><p>objects carry something, and the stuff is accessed using Python’s dot syntax</p><ul><li>carry: funciotn –&gt; method</li><li>carry: non-function –&gt; attributes</li></ul></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li><p>lists (mutable)</p><ul><li><p>indexing <code>list[0]</code></p></li><li><p>slicing <code>list[0:3] </code>   <code>list[-1:1]</code> </p></li><li><p>change <code>list[1]=&quot;second&quot;</code></p></li><li><p>list comprehensions</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">squares = [n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> ]</span><br><span class="line"></span><br><span class="line">squares = [</span><br><span class="line">    n**<span class="number">2</span> </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) </span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>functions</p><ul><li>len(list)</li><li>sorted(list)</li><li>sum(list)</li><li>max(list)   \   min(list)</li></ul></li><li><p>method   –&gt; help(list)  –&gt; learn all the method</p><ul><li>list.append()</li><li>list.pop()  : removes and returns the last element</li><li>searching<ul><li>“element” in list</li><li>list.index(‘element’)</li></ul></li></ul></li></ul></li></ul><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul><li>tuples(immutable)<ul><li>create<ul><li>t&#x3D;(1, 2, 3)</li><li>t&#x3D;1, 2, 3</li></ul></li><li>a, b &#x3D; b, a</li></ul></li></ul><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><ul><li>loops<ul><li>for planet in planets</li><li>for i in range(5)</li><li>while i&lt;10</li></ul></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li><p>Double quotes –&gt;  contains single quote charater</p></li><li><p>single quotes –&gt; contains double quote character</p></li><li><p>escaping –&gt; <code>\</code></p></li><li><p>string –&gt; sequnces of characters –&gt; list (immutable)</p><ul><li><p>index</p></li><li><p>slice</p></li><li><p>funcion</p></li><li><p>method for string</p><ul><li>.split()</li><li>.join()   <code>&#39;/&#39;.join([month, day, year])</code></li><li>str.format()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125;, you&#x27;ll always be the &#123;&#125;th planet to me.&quot;</span>.<span class="built_in">format</span>(planet, position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;&quot;Pluto&#x27;s a &#123;0&#125;.</span></span><br><span class="line"><span class="string">No, it&#x27;s a &#123;1&#125;.</span></span><br><span class="line"><span class="string">&#123;0&#125;!</span></span><br><span class="line"><span class="string">&#123;1&#125;!&quot;&quot;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;planet&#x27;</span>, <span class="string">&#x27;dwarf planet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;:10.5&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;xyz&#x27;</span>)    <span class="comment">#十个占位，5位有效数字</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="dictionaries"><a href="#dictionaries" class="headerlink" title="dictionaries"></a>dictionaries</h3><ul><li><p>create</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers = &#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>index  <code>index[&quot;one&quot;]</code></p></li><li><p>add <code>numbers[&quot;four&quot;]=4</code>]</p></li><li><p>change</p></li><li><p>dictionary comprehensions</p></li><li><p>‘one’ in numbers</p></li><li><p>遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(k,numbers[k]))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> k,num <span class="keyword">in</span> numbers.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(k,num) )</span><br><span class="line">    <span class="comment"># dict.items() = dict.keys() + dict.values()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="external-libraries"><a href="#external-libraries" class="headerlink" title="external libraries"></a>external libraries</h3><ul><li><p>understanding strange objects</p><ul><li><p><code>type()</code>   –&gt;  what is it </p></li><li><p><code>dir()</code>  –&gt; what can be done  (模块中定义的模块，哈桑函数，变量)</p></li><li><p><code>help()</code>  –&gt; more info</p></li></ul></li><li><p><strong>operator overloading</strong></p></li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><p>cmd <code>python</code> -&gt; 进入到交互环境；<code>quit</code></p></li><li><p>注释 <code>#</code> <code>&#39;&#39;&#39;</code> <code>&quot;&quot;&quot;</code></p></li><li><p><code>end=&#39;&#39;</code>表示输出后不换行 （默认的结束符<code>\n</code>）</p></li><li><p>大小写敏感</p></li><li><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>chr</code></td><td>整数-&gt;字符串</td></tr><tr><td><code>float</code></td><td>个字符串转换成浮点数</td></tr><tr><td><code>type</code></td><td>函数变量的类型进行检查</td></tr><tr><td><code>bin</code></td><td>整数-&gt;<code>&#39;0b&#39;</code>开头的二进制字符串</td></tr><tr><td><code>ord</code></td><td>字符串-&gt;整数</td></tr><tr><td><code>hex</code></td><td>整数-&gt;’0x’<code>开头的十六进制字符串，例如：</code>hex(123)<code>会返回</code>‘0x7b’&#96;</td></tr><tr><td><code>input</code></td><td>从输入中读取一行，返回读到的字符串。</td></tr><tr><td><code>open</code></td><td>打开一个文件并返回文件对象</td></tr><tr><td><code>round</code></td><td>四舍五入</td></tr><tr><td><code>range(100, 0, -2)</code></td><td>100到1的偶数</td></tr><tr><td><code>/</code>  <code>//</code> <code>**</code></td><td>除法 整除  指数</td></tr><tr><td><code>print()</code></td><td>来实现换行输出</td></tr></tbody></table></li><li><table><thead><tr><th><code>is</code> <code>is not</code></th><th>身份运算符</th></tr></thead><tbody><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr></tbody></table></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入华氏温度: &#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>*<span class="subst">&#123;j&#125;</span>=<span class="subst">&#123;i * j&#125;</span>&#x27;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()   <span class="comment">#来实现换行输出</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ... :</span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure></li><li><p><strong>Flat is better than nested</strong></p></li><li><p><strong>for-in循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):   <span class="comment">#[1,101)</span></span><br></pre></td></tr></table></figure></li><li><p>产生一个1-100范围的随机数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">answer = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">num</span>):</span><br><span class="line">....</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li><p>函数也可以没有自变量，但是函数名后面的圆括号是必须有的</p></li><li><p><code>def roll_dice(n=2):</code> 默认值为2,如果没有指定参数,那么n使用默认值2;传入参数3，变量n被赋值为3</p></li><li><p>带默认值的参数必须放在不带默认值的参数之后</p></li><li><p><strong>可变参数</strong>: 可变参数其实就是将多个参数打包成了一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 可变参数可以放在for循环中取出每个参数的值</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></li><li><p>用模块管理函数-&gt;解决命名冲突</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1 <span class="keyword">as</span> m1</span><br><span class="line"><span class="keyword">import</span> module2 <span class="keyword">as</span> m2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo <span class="comment">#导入同名函数，后导入覆盖先导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo <span class="keyword">as</span> f1</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo <span class="keyword">as</span> f2</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串-string-‘’"><a href="#字符串-string-‘’" class="headerlink" title="字符串(string ‘’)"></a>字符串(string ‘’)</h3><ul><li><p><strong>不可变类型</strong>-&gt;<strong>不能通过索引运算修改字符串中的字符</strong></p></li><li><p><code>\</code>（反斜杠）来表示转义</p><ul><li>\t    制表符</li><li>本身包含了<code>&#39;  \</code>这些特殊的字符，通过<code>\</code>进行转义处理</li></ul></li><li><p>原始字符串：以<code>r</code>或<code>R</code>开头 <code>s2 = r&#39;\time up \now&#39;</code></p></li><li><p><code>+</code>和<code>*</code> -&gt; 拼接和重复</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较字符串的内容</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2, s2 == s3)    <span class="comment"># True True</span></span><br><span class="line"><span class="comment"># 比较字符串的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s2, s2 <span class="keyword">is</span> s3)    <span class="comment"># False True</span></span><br></pre></td></tr></table></figure></li><li><p>成员运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;wo&#x27;</span> <span class="keyword">in</span> s1)    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;wo&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> s1)</span><br></pre></td></tr></table></figure></li><li><p>索引和切片</p><ul><li>正向索引 : 0<code>到</code>N-1</li><li>负向索引: -1<code>到</code>-N</li><li>切片: [i:j:k]</li></ul></li><li><p>循环遍历</p><ul><li><p>下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">    <span class="built_in">print</span>(s1[index])</span><br></pre></td></tr></table></figure></li><li><p>直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">    <span class="built_in">print</span>(ch)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找</p><ul><li><p>find</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到了返回字符串中另一个字符串首字符的索引</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;or&#x27;</span>))        <span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 找不到返回-1</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;shit&#x27;</span>))      <span class="comment"># -1</span></span><br></pre></td></tr></table></figure></li><li><p>index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到了返回字符串中另一个字符串首字符的索引</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&#x27;or&#x27;</span>))       <span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 找不到引发异常</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&#x27;shit&#x27;</span>))     <span class="comment"># ValueError: substring not found</span></span><br></pre></td></tr></table></figure></li><li><p>逆向查找:rfind<code>和</code>rindex</p></li></ul></li><li><p>格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># center方法以宽度20将字符串居中并在两侧填充*</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))  <span class="comment"># ****hello, world****</span></span><br><span class="line"><span class="comment"># rjust方法以宽度20将字符串右对齐并在左侧填充空格</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">20</span>))        <span class="comment">#         hello, world</span></span><br><span class="line"><span class="comment"># ljust方法以宽度20将字符串左对齐并在右侧填充~</span></span><br><span class="line"><span class="built_in">print</span>(s.ljust(<span class="number">20</span>, <span class="string">&#x27;~&#x27;</span>))   <span class="comment"># hello, world~~~~~~~~</span></span><br></pre></td></tr></table></figure></li><li><table><thead><tr><th>变量值</th><th>占位符</th><th>格式化结果</th><th>说明</th></tr></thead><tbody><tr><td><code>-1</code></td><td><code>&#123;:+.2f&#125;</code></td><td><code>&#39;-1.00&#39;</code></td><td>带符号保留小数点后两位</td></tr><tr><td><code>3.1415926</code></td><td><code>&#123;:.0f&#125;</code></td><td><code>&#39;3&#39;</code></td><td>不带小数</td></tr><tr><td><code>123</code></td><td><code>&#123;:0&gt;10d&#125;</code></td><td><code>0000000123</code></td><td>左边补<code>0</code>，补够10位</td></tr><tr><td><code>123</code></td><td><code>&#123;:x&lt;10d&#125;</code></td><td><code>123xxxxxxx</code></td><td>右边补<code>x</code> ，补够10位</td></tr><tr><td><code>123456789</code></td><td><code>&#123;:,&#125;</code></td><td><code>&#39;123,456,789&#39;</code></td><td>逗号分隔格式</td></tr><tr><td><code>0.123</code></td><td><code>&#123;:.2%&#125;</code></td><td><code>&#39;12.30%&#39;</code></td><td>百分比格式</td></tr><tr><td><code>123456789</code></td><td><code>&#123;:.2e&#125;</code></td><td><code>&#39;1.23e+08&#39;</code></td><td>科学计数法格式</td></tr></tbody></table></li><li><p><code>s.strip()</code> 修剪掉左右两端空格</p></li></ul><h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list [])"></a>列表(list [])</h3><ul><li><p>允许<strong>有重复</strong>的数据，可<strong>修改</strong>。列表底层是一个可以动态扩容的数组。</p></li><li><p>定义</p><ul><li><p>生成式 (最好)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;hello world&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27; aeiou&#x27;</span>]</span><br><span class="line">items2 = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(items3)    <span class="comment"># [&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;B1&#x27;, &#x27;B2&#x27;, &#x27;C1&#x27;, &#x27;C2&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>字面量语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items1 = [<span class="number">35</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">55</span>, <span class="number">87</span>]</span><br></pre></td></tr></table></figure></li><li><p>内置的<code>list</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(items1)    <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>拼接、重复、成员运算、索引,切片,比较</p><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表的重复</span></span><br><span class="line">items4 = [<span class="string">&#x27;hello&#x27;</span>] * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(items4)    <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>添加和删除</p><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用append方法在列表尾部添加元素</span></span><br><span class="line">items.append(<span class="string">&#x27;Swift&#x27;</span>)</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用insert方法在列表指定索引位置插入元素</span></span><br><span class="line">items.insert(<span class="number">2</span>, <span class="string">&#x27;SQL&#x27;</span>)</span><br></pre></td></tr></table></figure><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的元素</span></span><br><span class="line">items.remove(<span class="string">&#x27;Java&#x27;</span>)</span><br></pre></td></tr></table></figure><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定索引位置的元素</span></span><br><span class="line">items.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#和pop基本相同，但会返回删除的元素</span></span><br><span class="line"><span class="keyword">del</span> items[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items.clear()</span><br><span class="line"><span class="comment"># 清空列表中的元素    </span></span><br></pre></td></tr></table></figure></li><li><p>元素位置和次数</p><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找元素的索引位置</span></span><br><span class="line"><span class="built_in">print</span>(items.index(<span class="string">&#x27;Python&#x27;</span>))   </span><br><span class="line"><span class="comment">#从索引为3这个位置开始</span></span><br><span class="line"><span class="built_in">print</span>(items.index(<span class="string">&#x27;Java&#x27;</span>, <span class="number">3</span>))  </span><br></pre></td></tr></table></figure></li><li>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(items.count(<span class="string">&#x27;Python&#x27;</span>)) </span><br></pre></td></tr></table></figure></li><li><p>排序和反转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items.sort()</span><br><span class="line">items.reverse()</span><br></pre></td></tr></table></figure></li><li><p>嵌套的列表 -&gt; 表格或数学上的矩阵</p><ul><li><p>不能用<code>[[0] * 3] * 5]</code>这种方式来创建嵌套列表</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="元组–tuple"><a href="#元组–tuple" class="headerlink" title="元组–tuple ()"></a>元组–tuple ()</h3><ul><li><p>可重复，元组是<strong>不可变</strong>类型</p></li><li><p>定义</p><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个四元组</span></span><br><span class="line">t2 = (<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">40</span>, <span class="literal">True</span>, <span class="string">&#x27;四川成都&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>()</code>表示空元组</p></li><li><p>只有一个元素，需要加逗号，否则是改变运算优先级的圆括号。<code>(&#39;hello&#39;, )</code>和<code>(100, )</code>才是一元组，而<code>(&#39;hello&#39;)</code>和<code>(100)</code>只是字符串和整数</p></li></ul></li><li><p>打包和解包 （解包语法对所有的序列都成立）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> <span class="comment"># 打包</span></span><br><span class="line">i, j, k = a<span class="comment"># 解包</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span></span><br><span class="line">i, j, *k = a  <span class="comment">#星号变量会变成列表</span></span><br></pre></td></tr></table></figure></li><li><p>交换变量值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = b, c, a</span><br></pre></td></tr></table></figure></li><li><p>让函数返回多个值 -&gt; <code>return max_one, min_one</code>装成一个二元组然后返回,通过解包语法将二元组中的两个值分别赋给两个变量</p></li><li><p>元组和列表相互转换 <code>list()</code>  <code>tuple()</code></p></li><li><p><code>enumerate</code>  循环遍历取到一个二元组，解包之后第一个值是索引，第二个值是元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;items[index]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(items):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;item&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set {})"></a>集合(set {})</h3><ul><li><p>无序性-&gt;不能索引 ； 互异性-&gt; 去重 ； 确定性：<code>(not) in</code>成员运算</p></li><li><p>集合中的元素必须是<code>hashable</code>类型,通常不可变类型都是<code>hashable</code>类型 (集合本身也是可变类型)。集合底层使用了<strong>哈希存储</strong>的方式</p></li><li><p>不可变类型的集合，名字叫<code>frozenset</code>,可以作为<code>set</code>中的元素</p></li><li><p>创建</p><ul><li><p><code>&#123;&#125;</code>字面量语法 (至少有一个元素,否则是空字典)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器语法<code>set</code> (空集合可以使用<code>set()</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2 = <span class="built_in">set</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>生成式（同list）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set4 = &#123;num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>) <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> num % <span class="number">5</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运算</p><ul><li><code>in</code>和<code>not in </code></li><li>交并差 (&amp;|-)</li></ul></li><li><p>添加或删除</p><p>+ </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.add(33)</span><br></pre></td></tr></table></figure><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.discard(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建议先做成员运算再删除,因为不在集合中会引发KeyError异常</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> set1:</span><br><span class="line">    set1.remove(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(set1)    <span class="comment"># &#123;33, 1, 55, 1000&#125;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pop-&gt;随机删除一个元素并返回该元素</span></span><br><span class="line"><span class="built_in">print</span>(set1.pop())</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clear方法可以清空整个集合</span></span><br><span class="line">set1.clear()</span><br></pre></td></tr></table></figure></li><li><p>判断有无相同的元素可以使用<code>print(set1.isdisjoint(set2)) </code></p></li></ul><h3 id="字典（zip-）"><a href="#字典（zip-）" class="headerlink" title="字典（zip{}）"></a>字典（zip{}）</h3><ul><li><p><strong>字典中的键必须是不可变类型</strong> (列表，集合，字典不行，但是他们可以为键值)</p></li><li><p>定义</p><p>+ </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;王大锤&#x27;</span>,<span class="string">&#x27;age&#x27;</span>: <span class="number">55</span>,<span class="string">&#x27;weight&#x27;</span>: <span class="number">60</span>, &#125;</span><br></pre></td></tr></table></figure><ul><li><p>内置函数<code>dict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="built_in">dict</span>(name=<span class="string">&#x27;王大锤&#x27;</span>,age=<span class="number">55</span>,weight=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过Python内置函数zip压缩两个序列并创建字典</span></span><br><span class="line">items1 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="string">&#x27;ABCDE&#x27;</span>, <span class="string">&#x27;12345&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(items1)    <span class="comment"># &#123;&#x27;A&#x27;: &#x27;1&#x27;, &#x27;B&#x27;: &#x27;2&#x27;, &#x27;C&#x27;: &#x27;3&#x27;, &#x27;D&#x27;: &#x27;4&#x27;, &#x27;E&#x27;: &#x27;5&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>生成式语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items3 = &#123;x: x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person:</span><br><span class="line">    person[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><p>通过键获得值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取不到返回None或设定的默认值</span></span><br><span class="line"><span class="built_in">print</span>(students.get(<span class="number">1005</span>))    <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(students.get(<span class="number">1005</span>, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;无名氏&#x27;</span>&#125;))    <span class="comment"># &#123;&#x27;name&#x27;: &#x27;无名氏&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取字典中所有的键</span></span><br><span class="line"><span class="built_in">print</span>(students.keys())      <span class="comment"># dict_keys([1001, 1002, 1003])</span></span><br><span class="line"><span class="comment"># 获取字典中所有的值</span></span><br><span class="line"><span class="built_in">print</span>(students.values())    <span class="comment"># dict_values([&#123;...&#125;, &#123;...&#125;, &#123;...&#125;])</span></span><br><span class="line"><span class="comment"># 获取字典中所有的键值对</span></span><br><span class="line"><span class="built_in">print</span>(students.items()) </span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pop方法通过键删除键值,并返回该值</span></span><br><span class="line">stu1 = students.pop(<span class="number">1002</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用popitem方法删除字典中最后一组键值,返回对应的二元组</span></span><br><span class="line"><span class="comment"># 如果字典中没有元素，调用该方法将引发KeyError异常</span></span><br><span class="line">key, value = students.popitem()</span><br><span class="line"></span><br><span class="line"><span class="comment">#del,引不到对应的值，一样会引发KeyError异常</span></span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;王大锤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">del</span> person[<span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#setdefault可以更新字典中的键对应的值或向字典中存入新的键值对</span></span><br><span class="line">result = students.setdefault(<span class="number">1005</span>, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;方启鹤&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用update更新字典元素，相同的键会用新值覆盖掉旧值，不同的键会添加到字典中</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda</title>
      <link href="/2020/11/15/Linux/1_3_conda/"/>
      <url>/2020/11/15/Linux/1_3_conda/</url>
      
        <content type="html"><![CDATA[<h1 id="conda-基本命令"><a href="#conda-基本命令" class="headerlink" title="conda 基本命令"></a>conda 基本命令</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境</span></span><br><span class="line">conda create -n xxxx (python = <span class="number">3.5</span>)  <span class="comment"># 创建</span></span><br><span class="line">conda remove -n xxxx --<span class="built_in">all</span> <span class="comment"># 删除</span></span><br><span class="line">source activate xxxx <span class="comment"># 激活</span></span><br><span class="line">source deactivate <span class="comment"># 退出</span></span><br><span class="line">conda env <span class="built_in">list</span> <span class="comment"># 所有环境</span></span><br><span class="line">conda info -e <span class="comment"># 确认当前环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包管理</span></span><br><span class="line">conda <span class="built_in">list</span> <span class="comment"># 查看在当前环境中，已安装的包和对应版本</span></span><br><span class="line">conda <span class="built_in">list</span> -n xxxx <span class="comment"># xxxx环境下的包</span></span><br><span class="line">conda install (-n xxxx) x <span class="comment"># 在xxxx安装x</span></span><br><span class="line">conda update x / conda update</span><br><span class="line">conda remove x</span><br><span class="line">conda search x <span class="comment"># 查找可安装的包</span></span><br><span class="line">conda clean -p <span class="comment"># 删除没有用的包</span></span><br><span class="line">conda clean -y <span class="built_in">all</span> <span class="comment"># 删除所有的包和cache</span></span><br></pre></td></tr></table></figure><ul><li><p><code>conda update conda   </code>  升级</p></li><li><p>镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加Anaconda的TUNA镜像</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coursera批量下载</title>
      <link href="/2020/07/15/%E5%85%B6%E4%BB%96/4_couseradownload/"/>
      <url>/2020/07/15/%E5%85%B6%E4%BB%96/4_couseradownload/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/LoganDing/Coursera.org-Downloader">https://github.com/LoganDing/Coursera.org-Downloader</a></p></blockquote><h1 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h1><span id="more"></span><ol><li><p>进入python安装目录下<code>Scripts</code> ，并且将路径添加到系统path中</p><p><code>我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;系统变量-&gt;path-&gt;新建</code></p></li><li><p>安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coursera-dl</span><br></pre></td></tr></table></figure></li><li><p>运行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coursera-dl -u &lt;user&gt; -p &lt;pass&gt; &lt;coursename&gt;</span><br></pre></td></tr></table></figure><p><em>course_name一般在URL中learn&#x2F;course_name</em></p></li><li><p>若出现无法登录问题，添加cauth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coursera-dl -u &lt;user&gt; -p &lt;pass&gt; --cauth &lt;cauth&gt; &lt;coursename&gt;</span><br></pre></td></tr></table></figure><p>如何获取cauth？<code>f12-&gt;application-&gt;cookies(https://www.coursera.org/)-&gt;CAUTH</code></p></li><li><p>其他操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Without -p field:            coursera-dl -u &lt;user&gt; modelthinking-004</span><br><span class="line">Multiple classes:            coursera-dl -u &lt;user&gt; -p &lt;pass&gt; saas historyofrock1-001 algo-2012-002</span><br><span class="line">Filter by section name:      coursera-dl -u &lt;user&gt; -p &lt;pass&gt; -sf &quot;Chapter_Four&quot; crypto-004</span><br><span class="line">Filter by lecture name:      coursera-dl -u &lt;user&gt; -p &lt;pass&gt; -lf &quot;3.1_&quot; ml-2012-002</span><br><span class="line">Download only ppt files:     coursera-dl -u &lt;user&gt; -p &lt;pass&gt; -f &quot;ppt&quot; qcomp-2012-001</span><br><span class="line">Use a ~/.netrc file:         coursera-dl -n -- matrix-001</span><br><span class="line">Get the preview classes:     coursera-dl -n -b ni-001</span><br><span class="line">Download videos at 720p:     coursera-dl -n --video-resolution 720p ni-001</span><br><span class="line">Specify download path:       coursera-dl -n --path=C:\Coursera\Classes\ comnetworks-002</span><br><span class="line">Display help:                coursera-dl --help</span><br><span class="line"></span><br><span class="line">Maintain a list of classes in a dir:</span><br><span class="line">Initialize:              mkdir -p CURRENT/&#123;class1,class2,..classN&#125;</span><br><span class="line">Update:                  coursera-dl -n --path CURRENT `\ls CURRENT`</span><br></pre></td></tr></table></figure><p>回复下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coursera-dl -u &lt;user&gt; -p &lt;pass&gt; --resume sdn1-001</span><br></pre></td></tr></table></figure><p><em><code>CTRL+C</code>, partially downloaded files will be deleted from your disk and you have to start the download process from the beginning, other interruptions can use the restore</em></p></li></ol><h1 id="why？？（填坑）"><a href="#why？？（填坑）" class="headerlink" title="why？？（填坑）"></a>why？？（填坑）</h1><p><code>pip</code>：</p><p><code>cookie</code></p><p><code>cauth</code></p><p><code>f12</code></p><p><code>批处理</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> hacks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coursera/github慢</title>
      <link href="/2020/07/15/%E5%85%B6%E4%BB%96/4_dns_speedup/"/>
      <url>/2020/07/15/%E5%85%B6%E4%BB%96/4_dns_speedup/</url>
      
        <content type="html"><![CDATA[<h1 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h1><span id="more"></span><ol><li><p>查找域名对应的ip地址</p><blockquote><p>github:</p><ul><li><p>github.com</p></li><li><p>github.global.ssl.fastly.net</p></li></ul></blockquote><blockquote><p>coursera:</p><ul><li>d3c33hcgiwev3.cloudfront.net</li></ul></blockquote><p>域名解析网站</p><ul><li><a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></li><li><a href="http://ping.chinaz.com/d3c33hcgiwev3.cloudfront.net">http://ping.chinaz.com/d3c33hcgiwev3.cloudfront.net</a></li></ul></li><li><p>修改hosts <code>C:\Windows\System32\drivers\etc\hosts</code> 文件</p><blockquote><p><ip> &lt;域名&gt;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">87.248.214.183 static3.cdn.Ubi.com</span><br><span class="line">95.140.224.199 static2.cdn.Ubi.com</span><br><span class="line">87.248.214.183 static1.cdn.Ubi.com</span><br><span class="line">221.110.130.114 uplaypc-s-ubisoft.cdn.ubi.com</span><br><span class="line">221.110.130.114 uplaypc-s-ubisoft-ww.cdn.ubi.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">140.82.113.3 github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net </span><br><span class="line"></span><br><span class="line">52.84.167.78 d3c33hcgiwev3.cloudfront.net</span><br><span class="line">13.224.164.137 d3c33hcgiwev3.cloudfront.net</span><br><span class="line">13.224.164.148  d3c33hcgiwev3.cloudfront.net</span><br><span class="line">99.84.194.187  d3c33hcgiwev3.cloudfront.net</span><br><span class="line">52.84.186.109  d3c33hcgiwev3.cloudfront.net</span><br><span class="line">54.230.85.123 d3c33hcgiwev3.cloudfront.net</span><br><span class="line">13.224.164.137    d3c33hcgiwev3.cloudfront.net</span><br><span class="line">14.13.224.164.148    d3c33hcgiwev3.cloudfront.net</span><br><span class="line">15.13.224.164.208    d3c33hcgiwev3.cloudfront.net</span><br><span class="line">16.13.224.164.173   d3c33hcgiwev3.cloudfront.net</span><br><span class="line">17.31.13.78.66    d3c33hcgiwev3.cloudfront.net</span><br></pre></td></tr></table></figure><p>(混入奇奇怪怪的东西)</p></li><li><p>cmd中使用<code>ipconfig\flushdns</code></p></li></ol><h1 id="why（填坑？？）"><a href="#why（填坑？？）" class="headerlink" title="why（填坑？？）"></a>why（填坑？？）</h1><p><code>hosts</code>:其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p><p><code>dns</code>: ????</p>]]></content>
      
      
      
        <tags>
            
            <tag> hacks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino_代码</title>
      <link href="/2020/06/27/%E5%85%B6%E4%BB%96/2_arduino-code/"/>
      <url>/2020/06/27/%E5%85%B6%E4%BB%96/2_arduino-code/</url>
      
        <content type="html"><![CDATA[<h1 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h1><h2 id="数字I-O"><a href="#数字I-O" class="headerlink" title="数字I&#x2F;O"></a>数字I&#x2F;O</h2><h3 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h3><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在大多数Arduino控制板上 13号引脚都连接了一个标有“L”的LED灯</span></span><br><span class="line"><span class="type">int</span> led = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  pinMode(led, OUTPUT);     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  digitalWrite(led, HIGH);   <span class="comment">// 点亮LED</span></span><br><span class="line">  delay(<span class="number">1000</span>);           <span class="comment">// 等待一秒钟</span></span><br><span class="line">  digitalWrite(led, LOW);   <span class="comment">// 通过将引脚电平拉低，关闭LED</span></span><br><span class="line">  delay(<span class="number">1000</span>);           <span class="comment">// 等待一秒钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h3><p><img src="https://www.arduino.cn/data/attachment/forum/201801/20/211432ahrihu0suh111hrh.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    pinMode(i,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 从引脚2到引脚6，逐个点亮LED，等待1秒再熄灭LED</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(i,HIGH);</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    digitalWrite(i,LOW);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从引脚7到引脚3，逐个点亮LED，等待1秒再熄灭LED</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;<span class="number">2</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(i,HIGH);</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    digitalWrite(i,LOW);   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按键控制LED实验"><a href="#按键控制LED实验" class="headerlink" title="按键控制LED实验"></a>按键控制LED实验</h3><p><img src="https://www.arduino.cn/data/attachment/forum/201801/20/212234wfsxa702afgaamad.png"></p><p><strong>限流电阻</strong><br>一般LED的最大能承受的电流为25mA，如若直接将LED连接到电路中，当其点亮时，如果电流过大，很容易烧毁。如图2-24所示，我们在LED一端串联了一个电阻R2，这样做可以控制流过LED的电流，防止损坏LED。这个电阻我们称之为限流电阻。</p><p><strong>下拉电阻</strong><br>在2号引脚到GND之前，连接了一个阻值10K的电阻。如果没有该电阻，当未按下按键时，2号引脚会一直处于悬空 状态，此时使用digital Read() 读取2号引脚状态，会得到一个不稳定的值（可能是高，也可能是低）。添加这个R1电阻到地就是为了稳定引脚的电平，当引脚悬空时，就会识别为低电平。而这种将某节点通过电阻接地的做法，叫做下拉，这个电阻叫做下拉电阻。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buttonPin = <span class="number">2</span>;     <span class="comment">// 连接按键的引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ledPin =  <span class="number">13</span>;      <span class="comment">// 连接LED的引脚</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> buttonState = <span class="number">0</span>;         <span class="comment">// 存储按键状态的变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(ledPin, OUTPUT);      </span><br><span class="line">  pinMode(buttonPin, INPUT);     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 读取按键状态并存储在变量中</span></span><br><span class="line">  buttonState = digitalRead(buttonPin);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 检查按键是否被按下</span></span><br><span class="line">  <span class="comment">// 如果按键按下，那buttonState应该为高电平</span></span><br><span class="line">  <span class="keyword">if</span> (buttonState == HIGH) &#123;     </span><br><span class="line">    <span class="comment">// 点亮LED</span></span><br><span class="line">    digitalWrite(ledPin, HIGH);  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 熄灭LED</span></span><br><span class="line">    digitalWrite(ledPin, LOW); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进阶（上拉电阻）"><a href="#进阶（上拉电阻）" class="headerlink" title="进阶（上拉电阻）"></a>进阶（上拉电阻）</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201801/20/212701dvu4tmkujk3lvsdx.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buttonPin = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> buttonState = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  pinMode(buttonPin,INPUT_PULLUP);</span><br><span class="line">  pinMode(ledPin,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  buttonState = digitalRead(buttonPin);</span><br><span class="line">  <span class="comment">// 按住按键时，点亮LED；放开按键后，熄灭LED。</span></span><br><span class="line">  <span class="keyword">if</span>(buttonState==HIGH)</span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(ledPin,LOW);   <span class="comment">//上拉电阻</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(ledPin,HIGH);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进阶（按一下亮，按一下熄灭）"><a href="#进阶（按一下亮，按一下熄灭）" class="headerlink" title="进阶（按一下亮，按一下熄灭）"></a>进阶（按一下亮，按一下熄灭）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buttonPin = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>;</span><br><span class="line">boolean ledState=<span class="literal">false</span>;  </span><br><span class="line">boolean buttonState=<span class="literal">true</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP);</span><br><span class="line">  pinMode(ledPin,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 等待按键按下</span></span><br><span class="line"><span class="keyword">while</span>(digitalRead(buttonPin)==HIGH)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 当按键按下时，点亮或熄灭LED</span></span><br><span class="line">  <span class="keyword">if</span>(ledState==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(ledPin,LOW);</span><br><span class="line">    ledState=!ledState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(ledPin,HIGH);</span><br><span class="line">    ledState=!ledState;</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">500</span>);  <span class="comment">// 很重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序末尾有一个<code>delay(500)</code> 的延时，它在这里是极其<strong>重要</strong>的。删去这个延时操作，按键出现失灵。这是因为程序运行的非常快，没有了延时操作，你按下按键到放开按键的间隔时间虽然极短，但loop中的语句可能已经运行了很多次，很难确定你放开按键时正在运行的loop() 循环是点亮还是熄灭LED。我们使用延时操作来使两次按键间产生一定的间隔时间，在间隔时间内Arduino会忽略按键按下情况，从而达到<strong>区分两次按键</strong>的目的。</p><h2 id="模拟I-O的使用"><a href="#模拟I-O的使用" class="headerlink" title="模拟I&#x2F;O的使用"></a>模拟I&#x2F;O的使用</h2><h3 id="呼吸灯实验"><a href="#呼吸灯实验" class="headerlink" title="呼吸灯实验"></a>呼吸灯实验</h3><p><img src="https://www.arduino.cn/data/attachment/forum/201803/05/210943ipvv9qj2tvdxxqpk.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nt led = <span class="number">9</span>;           <span class="comment">// LED灯连接在9号引脚</span></span><br><span class="line"><span class="type">int</span> brightness = <span class="number">0</span>;     <span class="comment">// LED灯亮度</span></span><br><span class="line"><span class="type">int</span> fadeAmount = <span class="number">5</span>;   <span class="comment">// 亮度渐变值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(led, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  analogWrite(led, brightness);</span><br><span class="line">  brightness = brightness + fadeAmount;</span><br><span class="line">  <span class="keyword">if</span> (brightness == <span class="number">0</span> || brightness == <span class="number">255</span>) &#123;</span><br><span class="line">    fadeAmount = -fadeAmount ;</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delay(30) 的延时语句，这是为了让我们肉眼能观察到亮度调节的效果。如果没有这个语句，整个变化效果将一闪而过。</p><h4 id="进阶（控制呼吸灯的呼吸频率）"><a href="#进阶（控制呼吸灯的呼吸频率）" class="headerlink" title="进阶（控制呼吸灯的呼吸频率）"></a>进阶（控制呼吸灯的呼吸频率）</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201803/05/210944d0b0izhh002bbnqq.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ledPin = <span class="number">9</span>;  <span class="comment">// 9号引脚控制LED</span></span><br><span class="line"><span class="type">int</span> pot=A0;    <span class="comment">// A0引脚读取电位器输出电压</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123; </span><br><span class="line">  <span class="comment">// LED逐渐变亮</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fadeValue = <span class="number">0</span> ; fadeValue &lt;= <span class="number">255</span>; fadeValue +=<span class="number">5</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    analogWrite(ledPin, fadeValue);</span><br><span class="line"><span class="comment">// 读取电位器输出电压，除以5时为了缩短延时时间</span></span><br><span class="line"><span class="type">int</span> time=analogRead(pot)/<span class="number">5</span>;</span><br><span class="line">    delay(time);  <span class="comment">// 将time用于延时</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// LED逐渐变暗</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fadeValue = <span class="number">255</span> ; fadeValue &gt;= <span class="number">0</span>; fadeValue -=<span class="number">5</span>) </span><br><span class="line">  &#123; </span><br><span class="line">analogWrite(ledPin, fadeValue);</span><br><span class="line">    delay(analogRead(pot)/<span class="number">5</span>);  <span class="comment">// 读取电位器输出电压，并用于延时</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="光敏电阻检测环境光实验"><a href="#光敏电阻检测环境光实验" class="headerlink" title="光敏电阻检测环境光实验"></a>光敏电阻检测环境光实验</h3><p><img src="https://www.arduino.cn/data/attachment/forum/201803/05/212143wldvvylf33xqv33b.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void setup()</span><br><span class="line">&#123;</span><br><span class="line">  // 初始化串口</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">&#125;</span><br><span class="line">void loop() </span><br><span class="line">&#123;</span><br><span class="line">// 读出当前光线强度，并输出到串口显示</span><br><span class="line">  int sensorValue = analogRead(A0);</span><br><span class="line">  Serial.println(sensorValue);</span><br><span class="line">  delay(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.arduino.cn/data/attachment/forum/201803/05/212420xai1n4aicakauqii.jpg" alt="img"></p><p>由于电源波动或外界干扰等原因，输出的数据可能也会受到一定的影响，例如波动较大等现象，这时你可以通过读取多次传感器数值，求平均数的方法，减小数据的波动。</p><h2 id="串口的使用"><a href="#串口的使用" class="headerlink" title="串口的使用"></a>串口的使用</h2><h4 id="串口输出"><a href="#串口输出" class="headerlink" title="串口输出"></a>串口输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int counter=0; // 计数器</span><br><span class="line"> </span><br><span class="line">void setup() &#123;</span><br><span class="line">// 初始化串口</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop() &#123;</span><br><span class="line">// 每loop循环一次，计数器变量加1</span><br><span class="line">counter = counter+1;</span><br><span class="line">// 输出变量</span><br><span class="line">Serial.print(counter);</span><br><span class="line">// 输出字符</span><br><span class="line">Serial.print( &#x27;:&#x27; );</span><br><span class="line">// 输出字符串;</span><br><span class="line">Serial.println(&quot;Hellow World&quot;);</span><br><span class="line">delay(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="串口输入"><a href="#串口输入" class="headerlink" title="串口输入"></a>串口输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void setup() &#123;</span><br><span class="line">  // 初始化串口</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop() &#123;</span><br><span class="line">// 如果缓冲区中有数据，则读取并输出</span><br><span class="line">if(Serial.available()&gt;0)</span><br><span class="line">  &#123;</span><br><span class="line">    char ch=Serial.read();</span><br><span class="line">    Serial.print(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Arduino </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino基础</title>
      <link href="/2020/06/27/%E5%85%B6%E4%BB%96/2_arduino/"/>
      <url>/2020/06/27/%E5%85%B6%E4%BB%96/2_arduino/</url>
      
        <content type="html"><![CDATA[<h1 id="编程入门"><a href="#编程入门" class="headerlink" title="编程入门"></a>编程入门</h1><h2 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C\C++语言基础"></a>C\C++语言基础</h2><span id="more"></span><ul><li>浮点型数据的运算，速度较慢且可能有精度丢失。通常我们会把浮点型转换为整型来处理相关运算。如9.8cm，我们通常把换算为98mm来计算</li><li>存储字符时，字符需要用单引号引用，如<code>char col=’C’;</code> </li><li>相较于数组形式的定义方法，使用String类型定义字符串会占用更多的存储空间</li><li>Switch后的表达式结果只能是整形或字符型。如果要使用其他类型，则必须使用if语句</li></ul><h2 id="常用电子元件"><a href="#常用电子元件" class="headerlink" title="常用电子元件"></a>常用电子元件</h2><h4 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202407hn5028ql688082nn.jpg" alt="面包内部、.jpg"></p><h4 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202658ek379kisa3pi3vzh.jpg" alt="1.jpg"></p><p>下拉电阻：将某节点通过电阻接地的做法，叫做下拉，这个电阻叫做下拉电阻</p><p>上拉电阻：同下拉电阻一样，可以稳定I&#x2F;O口电平，不同的是电阻连接到VCC，将引脚稳定在高电位。</p><p>​可以用<code>pinMode(buttonPin,INPUT_PULLUP)</code>或者物理连接实现</p><h4 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202736q9kswuxis5nl825i.jpg" alt="2.jpg"></p><p>电容也有很多作用，如去耦、滤波、储能等</p><h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202812i9v9k8tly9hwhvxl.jpg" alt="3.jpg"></p><p>二极管在电路中使用广泛，作用众多，如整流、稳压、电路保护等</p><h4 id="LED（发光二极管"><a href="#LED（发光二极管" class="headerlink" title="LED（发光二极管"></a>LED（发光二极管</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202849hnqjq8mqtntmj8zm.jpg" alt="4.jpg"></p><p>一般LED的最大能承受的电流为25mA</p><h4 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201704/15/202929l3to1oz4wtwf6chn.jpg" alt="5.jpg"></p><p>三极管，能起放大、开关等作用的元件。<br>有发射极（emitter,E）、基极（base,B）和集电极（collector,C）三级，<br>有pnp和npn 两种类型的三极管。</p><h4 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201801/20/212948cbd22kta69immltw.jpg" alt="img"></p><h4 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h4><p><img src="https://www.arduino.cn/data/attachment/forum/201803/05/210944q3dre8qok1daddvt.png" alt="img"></p><p>电位器是一个可调电阻</p><h4 id="光敏电阻"><a href="#光敏电阻" class="headerlink" title="光敏电阻"></a>光敏电阻</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://www.arduino.cn/data/attachment/forum/201803/05/212142at6fw8a8rkx8n6ka.png" alt="img" style="zoom:67%;" /></h4><p>电阻值随照射光强度增加而下降的电阻</p><h1 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h1><p><img src="https://www.arduino.cn/data/attachment/forum/201801/20/210906pl8cbzbqyeiq8ill.jpg" alt="img"></p><h2 id="数字I-O的使用"><a href="#数字I-O的使用" class="headerlink" title="数字I&#x2F;O的使用"></a>数字I&#x2F;O的使用</h2><ol><li><p>新建变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LED 13</span><br><span class="line">int led = 13;</span><br></pre></td></tr></table></figure></li><li><p>配置引脚模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pinMode(pin, mode); </span><br></pre></td></tr></table></figure><blockquote><p>可使用的三种模式:</p><ul><li><strong>INPUT</strong>     输入模式</li><li><strong>OUTPUT</strong>     输出模式</li><li><strong>INPUT_PULLUP</strong>     输入上拉模式</li></ul></blockquote></li><li><p>输出高低电平</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digitalWrite(pin, value); //value= HIGH/LOW </span><br></pre></td></tr></table></figure></li><li><p>读取外部输入的数字信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int value = digitalRead(pin) </span><br></pre></td></tr></table></figure><blockquote><p>Arduino UNO会将大于3V的输入电压视为高电平，小于1.5V的电压视为低电平。超过5V的输入电压可能会损坏Arduino UN</p></blockquote></li></ol><p><em>在Arduino核心库中，OUTPUT被定义等于1，INPUT被定义等于0，HIGH被定义等于1，LOW被定义等于0，所以可以写成<code>pinMode(13,1);</code> <code> digitalWrite(13,1)</code>。但是不建议，因为可读性变差</em></p><ol start="5"><li><p>延时函数。在写程序的时候要注意写delay()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay() ; //ms</span><br></pre></td></tr></table></figure></li></ol><h2 id="模拟I-O的使用"><a href="#模拟I-O的使用" class="headerlink" title="模拟I&#x2F;O的使用"></a>模拟I&#x2F;O的使用</h2><ol><li><p>编号带“A”的引脚是模拟输入引脚。读取引脚上输入的电压大小。Arduino UNO上，可以接受0～5V的模拟信号。Arduino 模拟输入功能有10位精度，即可以将0～5V的电压信号转换为0～1023的整数形式表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int value = analogRead(pin)</span><br></pre></td></tr></table></figure></li><li><p>模拟输出功能。以脉冲宽度调制（PWM）来达到输出近似模拟值的效果。这里仅仅是得到了近似模拟值输出的效果，如果要输出真正的模拟值，还需要加上外围滤波电路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analogWrite(pin,value)</span><br></pre></td></tr></table></figure><p>value指定是PWM的脉冲宽度，范围为0～255。</p></li></ol><h2 id="串口的使用"><a href="#串口的使用" class="headerlink" title="串口的使用"></a>串口的使用</h2><p>Arduino与计算机通信最常用的方式就是串口通信。串口通信时，Arduino控制器上的标有RX&#x2F;TX的两LED灯会闪烁提示，接收数据时，RX灯会点亮；发送数据时，TX灯会点亮。</p><ol><li><p>使用串口与计算机通信，需要先使用Serial. Begin() 初始化Arduino的串口通信功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial.begin(speed);</span><br></pre></td></tr></table></figure><p>peed是指串口通信波特率,<strong>波特率</strong>是衡量通信速度的参数，表示每秒钟传送的bit的个数。串口通信的双方必须使用同样的波特率，方能正常进行通信。</p></li><li><p>串口输出。使用Serial. Print() 或Serial.println() 向计算机发送各种类型的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serial.print(val);</span><br><span class="line">Serial.println(val);  <span class="comment">//回车换行</span></span><br></pre></td></tr></table></figure></li><li><p>串口监视器是Arduino IDE自带的一个小工具，可以查看到串口传来的信息，也可以向连接的设备发送信息</p></li><li><p>缓冲区。在使用串口时，Arduino Uno会在SRAM中开辟一段大小为256 bytes的空间，串口接收到的数据都会被暂时存放进这个空间中，这个存储空间，我们称之为缓冲区。当你调用Serial. Read()语句时，Arduino便会从缓冲区取出一个字节的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial.available(); <span class="comment">//缓冲区中接收到的数据字节数</span></span><br></pre></td></tr></table></figure></li><li><p>串口输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erial.read(); <span class="comment">//每次都会返回一个字节的数据</span></span><br></pre></td></tr></table></figure><p>当缓冲区中没有可读数据时，read()函数会返回int型值-1，而int型-1对应的char型数据是乱码。所以要先判断缓冲区是否有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if( Serial.available() &gt; 0 ) </span><br><span class="line">while( Serial.available() &gt; 0 )</span><br></pre></td></tr></table></figure></li><li><p>特殊用法。等待串口监视器开启，开启串口监视器后，!Serial将为假</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (!Serial) &#123; &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Arduino </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2020/06/20/git/1_1_git-cheatsheet/"/>
      <url>/2020/06/20/git/1_1_git-cheatsheet/</url>
      
        <content type="html"><![CDATA[<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure><h1 id="版本回退删除"><a href="#版本回退删除" class="headerlink" title="版本回退删除"></a>版本回退删除</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status %查看仓库状态,是否有文件被修改过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt;   %working tree与index差别</span><br><span class="line">git diff --cached &lt;file&gt;  %index与repository差别</span><br><span class="line">git diff HEAD &lt;file&gt;    %查看working tree和repository差别。HEAD代表的是新commit的信息。</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log %查看提交日志</span><br><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^       %回退到上一个版本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a      %版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog  %查看每一次命令</span><br></pre></td></tr></table></figure><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h4 id="撤销工作区"><a href="#撤销工作区" class="headerlink" title="撤销工作区"></a>撤销工作区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  %把在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><h4 id="撤销暂存区"><a href="#撤销暂存区" class="headerlink" title="撤销暂存区"></a>撤销暂存区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; %把暂存区的修改撤销掉（unstage），重新放回工作区</span><br><span class="line">git checkout -- &lt;file&gt;  %把在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><h2 id="删除-恢复"><a href="#删除-恢复" class="headerlink" title="删除&amp;恢复"></a>删除&amp;恢复</h2><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt </span><br><span class="line">git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure><h4 id="恢复误删文件"><a href="#恢复误删文件" class="headerlink" title="恢复误删文件"></a>恢复误删文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h4 id="关联仓库"><a href="#关联仓库" class="headerlink" title="关联仓库"></a>关联仓库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin </span><br><span class="line">git@github.com:&lt;github_user_name&gt;/&lt;github_repo_name &gt;.git</span><br></pre></td></tr></table></figure><h4 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  % 第一次</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:m&lt;user_name&gt;/&lt;repo_name&gt;.git</span><br><span class="line">git clone https://github.com/&lt;user_name&gt;/&lt;repo_name&gt;.git</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h4 id="创建切换"><a href="#创建切换" class="headerlink" title="创建切换"></a>创建切换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev 创建并切换</span><br><span class="line">$ git branch dev     % 创建</span><br><span class="line">$ git checkout dev   % 切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev   %创建并切换</span><br><span class="line">$ git switch master   %创建</span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev     %用于合并指定分支到当前分支</span><br><span class="line">$ git merge --no-ff -m &quot;&lt;message&gt;&quot; dev   %合并后显示分支信息</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">git branch -D &lt;name   % 强行删除未合并分支</span><br></pre></td></tr></table></figure><h4 id="储藏现场"><a href="#储藏现场" class="headerlink" title="储藏现场"></a>储藏现场</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list    %查看工作现场</span><br></pre></td></tr></table></figure><h4 id="恢复现场"><a href="#恢复现场" class="headerlink" title="恢复现场"></a>恢复现场</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line">git stash drop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h4 id="复制一个特定的提交到当前分支"><a href="#复制一个特定的提交到当前分支" class="headerlink" title="复制一个特定的提交到当前分支"></a>复制一个特定的提交到当前分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure><h4 id="查看远程库的信息"><a href="#查看远程库的信息" class="headerlink" title="查看远程库的信息"></a>查看远程库的信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">$ git remote -v   %详细信息</span><br></pre></td></tr></table></figure><h3 id="推动分支"><a href="#推动分支" class="headerlink" title="推动分支"></a>推动分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><h4 id="创建远程origin的dev分支到本地"><a href="#创建远程origin的dev分支到本地" class="headerlink" title="创建远程origin的dev分支到本地"></a>创建远程<code>origin</code>的<code>dev</code>分支到本地</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h4 id="指定本地dev分支与远程origin-dev分支的链接"><a href="#指定本地dev分支与远程origin-dev分支的链接" class="headerlink" title="指定本地dev分支与远程origin/dev分支的链接"></a>指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><h4 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0   % 打在最新提交的commit上</span><br><span class="line">$ git tag v0.9 f52c633  %打在指定commit上</span><br><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb   %指定标签名&amp;说明文字</span><br></pre></td></tr></table></figure><h4 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><h4 id="查看标签信息"><a href="#查看标签信息" class="headerlink" title="查看标签信息"></a>查看标签信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br></pre></td></tr></table></figure><h4 id="本地删除"><a href="#本地删除" class="headerlink" title="本地删除"></a>本地删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br></pre></td></tr></table></figure><h4 id="推送到远程-1"><a href="#推送到远程-1" class="headerlink" title="推送到远程"></a>推送到远程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">$ git push origin --tags    % 推送所有</span><br></pre></td></tr></table></figure><h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9% 本地删除</span><br><span class="line">$ git push origin :refs/tags/v0.9% 远程删除</span><br></pre></td></tr></table></figure><h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><h4 id="显示颜色"><a href="#显示颜色" class="headerlink" title="显示颜色"></a>显示颜色</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class   %添加已经被忽略的文件</span><br><span class="line">$ git check-ignore -v App.class  %检查ignore</span><br></pre></td></tr></table></figure><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status   %有空格要&#x27;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2020/06/17/git/1_1_git-tutotial/"/>
      <url>/2020/06/17/git/1_1_git-tutotial/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>分布式版本控制系统</p><span id="more"></span><h2 id="集中式-vs-分布式-版本控制系统"><a href="#集中式-vs-分布式-版本控制系统" class="headerlink" title="集中式 vs 分布式 版本控制系统"></a>集中式 vs 分布式 版本控制系统</h2><p>集中式版本控制系统版本库存放在中央处理器，需要联网，服务器挂了就都挂了</p><p>分布式版本控制系统，没有“中央服务器”，每台电脑都是完整的版本库，不需要联网，安全性高</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><h2 id="创建版本库（repository）"><a href="#创建版本库（repository）" class="headerlink" title="创建版本库（repository）"></a>创建版本库（repository）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;name for file&gt;</span><br><span class="line">cd &lt;file path&gt;</span><br><span class="line">git init </span><br></pre></td></tr></table></figure><p>过<code>git init</code>命令把这个目录变成Git可以管理的仓库，生成<code>.git</code>目录（隐藏）</p><h2 id="添加文件到版本库—注意事项"><a href="#添加文件到版本库—注意事项" class="headerlink" title="添加文件到版本库—注意事项"></a>添加文件到版本库—注意事项</h2><p>版本控制系统，本质是跟踪文本文件的改动。所以图片片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>Microsoft的Word格式是二进制格式，所以要用纯文本编写文件</p><p>万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，会带来很多错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure><h1 id="版本回退、修改、删除"><a href="#版本回退、修改、删除" class="headerlink" title="版本回退、修改、删除"></a>版本回退、修改、删除</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status %查看仓库状态,是否有文件被修改过</span><br></pre></td></tr></table></figure><p>工作区（<strong>working tree</strong>），暂存区（<strong>index &#x2F;stage</strong>），本地仓库（<strong>repository</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt;  %working tree与index差别</span><br><span class="line">git diff --cached &lt;file&gt;  %index与repository差别</span><br><span class="line">git diff HEAD &lt;file&gt;  %查看working tree和repository差别。HEAD代表的是新commit的信息。</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h2 id="版本回退至最近的commit"><a href="#版本回退至最近的commit" class="headerlink" title="版本回退至最近的commit"></a>版本回退至最近的commit</h2><h3 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log %查看提交日志</span><br></pre></td></tr></table></figure><p>输出信息（eg）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)% 版本号</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL% &lt;message&gt;</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><p>输出信息（eg）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>版本号（commit id）是一个很大的十六进制数。多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了</li><li><code>HEAD</code> 表示当前版本，<code>HEAD^</code>上一个版本,<code>HEAD^^</code>上上版本，<code>HEAD~100</code>上一百个版本</li></ul><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^       %回退到上一个版本</span><br></pre></td></tr></table></figure><p>若想再回到最新版本，需要找到它的版本号。此时使用<code>git log</code>看不到最新版本，使用<code>git reflog</code>查看每一次命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a      %版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="撤销工作区"><a href="#撤销工作区" class="headerlink" title="撤销工作区"></a>撤销工作区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  %把在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><p>即回到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><p><strong>不要忘记<code>--</code>  ， <code>git checkout &lt;&gt;</code>是切换到另一个分支</strong></p><h4 id="撤销暂存区"><a href="#撤销暂存区" class="headerlink" title="撤销暂存区"></a>撤销暂存区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; %把暂存区的修改撤销掉（unstage），重新放回工作区</span><br><span class="line">git checkout -- &lt;file&gt;  %把在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><h4 id="撤销版本库"><a href="#撤销版本库" class="headerlink" title="撤销版本库"></a>撤销版本库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^       %回退到上一个版本</span><br></pre></td></tr></table></figure><p>前提：未推送到远程仓库</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br><span class="line">git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="恢复误删文件"><a href="#恢复误删文件" class="headerlink" title="恢复误删文件"></a>恢复误删文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul><li><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密</p></li><li><p>用户主目录 -&gt; .ssh目录     找到对应的<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</p></li><li><p><code>id_rsa</code>是私钥，不能泄露出去;<code>id_rsa.pub</code>是公钥，可以告诉任何人</p></li><li><p>登陆GitHub，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p></li></ul><h2 id="本地库添加到远程库（不常用，一般克隆）"><a href="#本地库添加到远程库（不常用，一般克隆）" class="headerlink" title="本地库添加到远程库（不常用，一般克隆）"></a>本地库添加到远程库（不常用，一般克隆）</h2><ol><li><p>创建本地仓库</p></li><li><p>github上创建仓库</p></li><li><p>关联仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin </span><br><span class="line">git@github.com:&lt;github_user_name&gt;/&lt;github_repo_name &gt;.git</span><br></pre></td></tr></table></figure><p>这里是ssh推送，速度快；也可以使用http推送,但是每次需要输入口令。</p></li><li><p>将本地库master分支推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li></ol><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ol><li><p>github上创建仓库</p></li><li><p>克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:m&lt;user_name&gt;/&lt;repo_name&gt;.git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/&lt;user_name&gt;/&lt;repo_name&gt;.git</span><br></pre></td></tr></table></figure></li></ol><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点</li></ol><p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial"></p><ol start="2"><li>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</li></ol><p><img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create"></p><ol start="3"><li>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变</li></ol><p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd"></p><ol start="4"><li>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并</li></ol><p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"></p><ol start="5"><li>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支</li></ol><p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm"></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li><p>创建<code>dev</code>分支，然后切换到<code>dev</code>分支</p><p>1.1 法一</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure><p><code>it checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev     % 创建</span><br><span class="line">$ git checkout dev   % 切换</span><br></pre></td></tr></table></figure><ul><li>撤销修改则是<code>git checkout -- &lt;file&gt;</code></li></ul><p>1.2 法二</p><p>切换分支这个动作，用<code>switch</code>更科学</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev   %创建并切换</span><br><span class="line">$ git switch master   %创建</span><br></pre></td></tr></table></figure><hr><p>用<code>git branch</code>命令查看当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev   % 当前分支前面会标一个*号</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></li><li><p>在<code>dev</code>分支上修改，提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br></pre></td></tr></table></figure></li><li><p>切换回master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/919022533080576/0" alt="git-br-on-master"></p></li><li><p>把<code>dev</code>分支的工作成果合并到<code>master</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev     %用于合并指定分支到当前分支</span><br><span class="line"></span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>Fast-forward</code>告诉我们这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p></li><li><p>删除<code>dev</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure></li></ol><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>原因：<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，必须手动解决冲突后再提交</p><ol><li><p>找到冲突文件（2种）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p><code>git status</code>也可以告诉我们冲突的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>修改冲突文件。在冲突文件中Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，例如</p></li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Git is a distributed version control system.</span><br><span class="line">&gt;Git is free software distributed under the GPL.</span><br><span class="line">&gt;Git has a mutable index called stage.</span><br><span class="line">&gt;Git tracks changes of files.</span><br><span class="line">&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&gt;Creating a new branch is quick &amp; simple.</span><br><span class="line">&gt;=======</span><br><span class="line">&gt;Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li><p>提交。<code>master</code>分支和<code>feature1</code>分支变成了下图所示</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023031831104/0" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph </span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit % (好看的)</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d f&lt;name&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h4 id="合并后显示分支信息"><a href="#合并后显示分支信息" class="headerlink" title="合并后显示分支信息"></a>合并后显示分支信息</h4><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"></p><p>要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><ul><li><code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</li><li>本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</li></ul><p>合并后，我们用<code>git log</code>看看分支历史</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p><h4 id="常见分支策略"><a href="#常见分支策略" class="headerlink" title="常见分支策略"></a>常见分支策略</h4><ul><li><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活</li><li>干活都在<code>dev</code>分支，版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，再在<code>master</code>发布</li><li>每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并</li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" alt="git-br-policy"></p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，当前正在<code>dev</code>上进行的工作还没有提交，工作只进行到一半，还没法提交。</p><p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>用<code>git status</code>查看工作区，就是干净的。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支。修复bug，然后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支</p><p>接着回到<code>dev</code>分支干活</p><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><ul><li><p>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br></pre></td></tr></table></figure></li><li><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li></ul><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令<code>git cherry-pick &lt;commit&gt;</code>，让我们能复制一个特定的提交到当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h2 id="feature分支删除"><a href="#feature分支删除" class="headerlink" title="feature分支删除"></a>feature分支删除</h2><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推动分支："><a href="#推动分支：" class="headerlink" title="推动分支："></a>推动分支：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><p><code>master</code>分支是主分支，因此要时刻与远程同步；</p></li><li><p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</p></li></ul><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。</p><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br><span class="line"></span><br><span class="line">error: failed to push some refs </span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push。</p><hr><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag）。</p><p>tag是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><blockquote><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p></blockquote><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p><code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0   % 打在最新提交的commit上</span><br><span class="line">$ git tag v0.9 f52c633  %打在指定commit上</span><br></pre></td></tr></table></figure><p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签（标签不是按时间顺序列出，而是按字母排序的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p>用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br></pre></td></tr></table></figure><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br></pre></td></tr></table></figure><p>推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br></pre></td></tr></table></figure><p>一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><p>删除远程标签就麻烦一点，先从本地删除<code>git tag -d &lt;tagname&gt;</code>，然后，从远程删除<code>git push origin :refs/tags/&lt;tagname&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9% 本地删除</span><br><span class="line">$ git push origin :refs/tags/v0.9% 远程删除</span><br></pre></td></tr></table></figure><h1 id="自定义git"><a href="#自定义git" class="headerlink" title="自定义git"></a>自定义git</h1><p>让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><ul><li><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们</p><p>Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去</p></li><li><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了。如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure></li><li><p><code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.classApp.class</span><br></pre></td></tr></table></figure><p>  Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p></li></ul><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用</p><p>配置文件放哪了？</p><p>当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中</p><p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统/虚拟机网络连接</title>
      <link href="/2020/03/01/Linux/1_2_linux_system_and_VM/"/>
      <url>/2020/03/01/Linux/1_2_linux_system_and_VM/</url>
      
        <content type="html"><![CDATA[<h1 id="linux系统-虚拟机网络连接"><a href="#linux系统-虚拟机网络连接" class="headerlink" title="linux系统&#x2F;虚拟机网络连接"></a>linux系统&#x2F;虚拟机网络连接</h1><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><ol><li><p><strong>linux内核</strong>（linus 团队管理）</p></li><li><p><strong>shell</strong>：用户与内核交互的接口 </p><p>Shell可以执行：</p><ul><li><strong>内部命令</strong></li><li><strong>应用程序</strong></li><li><strong>shell脚本</strong></li></ul></li><li><p><strong>文件系统</strong>：ext3、ext4等。windows 有 fat32 、ntfs</p></li><li><p><strong>第三方应用软件</strong></p></li></ol><h2 id="系统分区"><a href="#系统分区" class="headerlink" title="系统分区"></a>系统分区</h2><ol><li><p>分区类型</p><ul><li>主分区：最多四个</li><li>扩展分区<ul><li>最多一个</li><li>主分区+扩展分区 &lt;&#x3D; 4</li><li>只能包含逻辑分区，不能写入数据</li></ul></li><li>逻辑分区：<ul><li>可正常格式化，并写入数据</li><li>逻辑分区永远从5开始</li></ul></li></ul><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210301185714514.png" alt="image-20210301185714514" style="zoom: 50%;" /><p>1，2，3，4：主分区       5，6 逻辑分区</p><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210301185923398.png" alt="image-20210301185923398" style="zoom:50%;" /><p>1，2：主分区   5，6，7，8：逻辑分区</p></li><li><p>格式化的目的：写入系统文件</p><ul><li>分成block</li><li>建立inode列表</li></ul></li><li><p>硬件设备文件名：Linux所有硬件都是文件，在<code>dev</code>目录下</p><table><thead><tr><th align="center">硬件</th><th>设备文件名</th></tr></thead><tbody><tr><td align="center">SCSI&#x2F;SATA&#x2F;USB</td><td>&#x2F;dev&#x2F;sd[a-d]</td></tr><tr><td align="center">打印机</td><td>&#x2F;dev&#x2F;lp[0-2]</td></tr><tr><td align="center">鼠标</td><td>&#x2F;dev&#x2F;mouse</td></tr></tbody></table><p>eg. sda1: 第一块硬盘接口的第一个block</p></li><li><p>windows: 分区-格式化-分配盘符</p><p>Linux：    分区-格式化-建立设备文件名（系统自己处理）-挂载（分配盘符，必须是空目录）</p></li><li><p>挂载</p><ul><li>必须分区：<ul><li>&#x2F;</li><li>swap （交换分区，类比虚拟内存）</li></ul></li><li>推荐分区<ul><li>&#x2F;boot （一般200MB，防止根分区写满影响启动）</li></ul></li></ul><p>ps. 根分区的子目录可指定独立的硬盘空空间</p><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210301192417748.png" alt="image-20210301192417748" style="zoom: 33%;" /></li></ol><h3 id="补充：硬盘的总线协议与接口"><a href="#补充：硬盘的总线协议与接口" class="headerlink" title="补充：硬盘的总线协议与接口"></a>补充：硬盘的总线协议与接口</h3><p>总线（bus）: 不同设备之间交互数据的通路 （eg. CPU 和 硬盘）</p><p>总线的带宽：总线单位时间能传输的数据量</p><p>协议（protocal）：两个设备具有相同协议才能通信</p><p>–&gt; 硬盘和其他电脑原件交互数据：数据协议（沟通）+传输总线（媒介）+物理接口（接入)  (三者必须匹配)</p><ul><li><p>目前硬盘数据协议：</p><ul><li>IDE(淘汰)</li><li>AHCI</li><li>NVMe</li><li>SCSI（服务器）</li></ul></li><li><p>目前数据传输总线：</p><ul><li>SATA</li><li>PCIe</li><li>SAS(服务器)</li></ul></li></ul><p><img src="C:\Users\Ashley\AppData\Roaming\Typora\typora-user-images\image-20210301191309437.png" alt="image-20210301191309437"></p><h2 id="Linux基本目录结构"><a href="#Linux基本目录结构" class="headerlink" title="Linux基本目录结构"></a>Linux基本目录结构</h2><p><img src="https://pic2.zhimg.com/v2-1f6cdbc3e0765ae8484624eaa2a08ab9_b.jpg" alt="img"></p><ul><li><strong>&#x2F;bin 存放系统命令 -二进制可执行文件(ls,cat,mkdir等)</strong>   普通用户和超级用户都能执行</li><li>&#x2F;sbin：存放系统命令 （super：只有root能执行）</li><li>&#x2F;usr&#x2F;bin: 在单用户模式下不能执行</li><li>&#x2F;boot: 系统启动目录表</li><li>&#x2F;dev 用于存放设备文件</li><li><strong>&#x2F;etc 存放系统配置文件</strong></li><li>&#x2F;home 普通用户的家目录</li><li>&#x2F;lib 系统调用的函数库</li><li>&#x2F;lost+found: 系统意外崩溃或者关机时产生的碎片文件</li><li>&#x2F;mnt 挂在额外设备（USB…）</li><li>&#x2F;proc 保存在内存中（不要往里面写东西）</li><li>&#x2F;sys   保存在内存中（不要往里面写东西）</li><li><strong>&#x2F;root 超级用户的家目录</strong></li><li>&#x2F;srv服务数据目录</li><li>&#x2F;tmp 临时目录</li><li>&#x2F;usr （Unix software resource）用于存放系统应用程序，比较重要的目录&#96;&#96;&#x2F;usr&#x2F;local&#96;  <strong>本地管理员软件安装目录</strong>**</li><li>&#x2F;var 存放动态数据（日志）</li></ul><h2 id="linux-注意点"><a href="#linux-注意点" class="headerlink" title="linux 注意点"></a>linux 注意点</h2><ol><li><p>Linux所有内容以文件形式保存，所以命令行更改时临时生效</p></li><li><p>严格区分大小写</p></li><li><p>不靠扩展名区分文件类型（写扩展名是为了方便使用）</p><table><thead><tr><th>压缩包</th><th>.gz   .bz2     .tar    .bz2    . tgz</th></tr></thead><tbody><tr><td>二进制软件包</td><td>.rpm</td></tr><tr><td>网页文件</td><td>.html   .php</td></tr><tr><td>脚本文件</td><td>.sh</td></tr><tr><td>配置文件</td><td>.config</td></tr></tbody></table></li><li><p>linux 所有的存储设备都必须挂载后才能使用  （eg. USB， 光盘， 硬盘）</p></li></ol><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><ul><li>桥接： 利用真实网卡，可以和局域网内设备交流</li><li>其他：只能和本机通信，但是不占用ip地址<ul><li>NAT: 如果主机能访问互联网，虚拟机就能够访问</li><li>Host-only：只能和主机通信 （无网）</li></ul></li></ul><p>ps. </p><ol><li><p>ifconfig eth0 <code>ip地址</code> -&gt; 配置ip地址   （if：interface网卡）</p></li><li><p>ping <code>ip地址</code> -&gt; 测试是否能通信成功</p></li><li><p>重启后ip地址丢失，要永久保留需要写入config文件</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
